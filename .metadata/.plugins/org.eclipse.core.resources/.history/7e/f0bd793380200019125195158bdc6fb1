/**
 * 
 */
package com.livespread.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.log4j.Logger;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataAccessException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import com.google.common.collect.Lists;
import com.livespread.command.ArsPoCommand;
import com.livespread.command.FinancialItemsCommand;
import com.livespread.command.NormInputParamers;
import com.livespread.command.NormalisedLabelAndValues;
import com.livespread.command.NormalisedParserOutput;
import com.livespread.command.NormalizationBreakupData;
import com.livespread.command.NormalizeFormData;
import com.livespread.command.NormalizeViewForDebitACHCommand;
import com.livespread.command.NormalizedDetails;
import com.livespread.command.NotesCheckListCommand;
import com.livespread.command.ParserOutputCommand;
import com.livespread.command.PdfExtractionMetadatCommand;
import com.livespread.command.ScaleChangeSignPoMappingCommand;
import com.livespread.command.ScaleCommand;
import com.livespread.command.ValueCommand;
import com.livespread.common.NormalizedDetailsByDisplaySequenceComparator;
import com.livespread.common.NormalizedDetailsComparator;
import com.livespread.common.NormalizedDetailsComparatorForSourceData;
import com.livespread.common.NormalzedLabelsDetailsComparator;
import com.livespread.common.SectionWiseComparator;
import com.livespread.dao.NormalizationViewDAO;
import com.livespread.dao.RageDAO;
import com.livespread.domain.ArsPoMapping;
import com.livespread.domain.AsRepStatement;
import com.livespread.domain.CompanyNotes;
import com.livespread.domain.DownloadTemplateControllerAssociation;
import com.livespread.domain.FileUploadModel;
import com.livespread.domain.Filings;
import com.livespread.domain.FinancialItems;
import com.livespread.domain.InvokeProcessTracker;
import com.livespread.domain.LanguageMappingMetadata;
import com.livespread.domain.NIBankValues;
import com.livespread.domain.NIValues;
import com.livespread.domain.NamedNativeQueryName;
import com.livespread.domain.NamedQueryName;
import com.livespread.domain.NormItemLabels;
import com.livespread.domain.NormQaChecksMeta;
import com.livespread.domain.NotesCheckList;
import com.livespread.domain.POCordHighlightDetails;
import com.livespread.domain.ParserOutput;
import com.livespread.domain.ParserOutputAudit;
import com.livespread.domain.ParserOutputAuditTrail;
import com.livespread.domain.QACheckFilterMapping;
import com.livespread.domain.QAMessageChecklist;
import com.livespread.domain.Scale;
import com.livespread.domain.ScaleChangeSignPoMapping;
import com.livespread.domain.SectionMappingModel;
import com.livespread.domain.TemplateSectionOrder;
import com.livespread.domain.User;
import com.livespread.domain.UserGroupsAttributeMapping;
import com.livespread.domain.WorkQueue;
import com.livespread.excel.StyleBuilder;
import com.livespread.rage.domain.ExtractorTableidRouteByCik;
import com.livespread.rage.domain.PdfExtractionMetadata;
import com.livespread.rage.domain.RageSequenceMaster;
import com.livespread.rage.domain.RequestQueue;
import com.livespread.rage.domain.SectionIdentification;
import com.livespread.util.CipherUtils;
import com.livespread.util.ExcelImportJDBCBatchUpdate;
import com.livespread.util.GetMaxYearMonthAndPeriod;
import com.livespread.util.LiveSpreadUtil;
import com.livespread.util.ProcessListGenerator;
import com.livespread.util.ReleaseLockedUser;
import com.livespread.util.UploadUtility;
import com.rage.extendeddao.ExtendedGenericDao;
import com.rage.reusable.constants.ReusableConstant;
/**
 * @author Bilal.Mistri
 * 
 */

@Service("normalizationService")
public class NormalizationServiceImpl implements NormalizationService {

	/**
	 * 
	 */

	private Logger LOGGER = Logger.getLogger(NormalizationServiceImpl.class);

	@Autowired
	private ExtendedGenericDao genericDaoImpl;

	@Autowired
	private ExtractionService extractionService;

	@Autowired
	private WorkQueueService workQueueService;
	
	@Autowired
	private QAMessageChecklistService qaMessageChecklistService;

	@Autowired
	private FileUploadService fileUploadService;
	
	@Value("${rageApplicationName}")
	private String rageApplicationName;
	
	@Value("${mappingNormalizationMaster}")
	private String mappingNormalizationMaster;
	
	@Value("${segmentMerge}")
	private String segmentMerge;
	
	@Value("${rageMultithreading}")
	private String rageMultithreading;
	

	@Autowired
	private POCordHighlightDetailsService poCordHighlightDetailsService;
	
	@Autowired
	private NormalizationViewDAO normalizationViewDAO;
	
	@Autowired
	private RageDAO rageDao;
	
	public static final DecimalFormat decimalFormat = new DecimalFormat("###,###,##0.00");

	DateFormat bkNormalizationformatter = new SimpleDateFormat("MMM-yyyy");
	SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy");
	DateFormat inputFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

	@Override
	public List<ParserOutput> getNormalizedData(NormInputParamers inputParameters) {
 		LOGGER.info("getNormalizedData started");
		List<ParserOutput> parserOutput = null;
		try {
			parserOutput = normalizationViewDAO.getParserOutputByFilingIdandStatementType(inputParameters);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return parserOutput;
	}

	/*
	 * This methode used for normalized data for enhanced public parser
	 */
	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutput> getNormalizedDataForEnhancedPublicParser(
			String stmtFormat, int WqId, int fillingId,Integer startNum,Integer endNum) {
		LOGGER.info("getNormalizedData started");
		LOGGER.debug("getNormalizedData started with" + stmtFormat + WqId);
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("statementType", stmtFormat);
		parameterMap.put("start", startNum);
		parameterMap.put("end", endNum);
		List<ParserOutput> parserOutput = (List<ParserOutput>)(Object)genericDaoImpl
				.findByNamedQuery(
						NamedQueryName.getNormalizedDataByFilingIdandStatementType_Q1,
						ParserOutput.class, parameterMap);

		LOGGER.info("getNormalizedData completed with result");
		return parserOutput;
	}

	@Override
	public List<Object> getNormalizedDataForXsl(int WqId, int fillingId) {
		LOGGER.info("getNormalizedDataForXsl started");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		List<Object> parserOutput = genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getNormalizedDataByFilingIdandStatementTypeForXsl,
						ParserOutput.class, parameterMap);
		LOGGER.info("getNormalizedDataForXsl completed with result");
		return parserOutput;
	}

	@Override
	public List<Object> getNormalizedDataForDealerFormXsl(int WqId,int fillingId,String sectionName) {
		LOGGER.info("getNormalizedDataForDealerFormXsl started");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("sectionName", sectionName);
		List<Object> parserOutput = genericDaoImpl.findByNativeNamedQuery(
				NamedNativeQueryName.getNormalizedDataForDealerFormXsl,
				ParserOutput.class, parameterMap);
		LOGGER.info("getNormalizedDataForDealerFormXsl completed with result");
		return parserOutput;
	}

	@Override
	public List<Object> getNormalizedDataForSUPPLXsl(int WqId, int fillingId) {
		LOGGER.info("getNormalizedDataForXsl started");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		List<Object> parserOutput = genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getNormalizedDataByFilingIdandStatementTypeForSUPPLXsl,
						ParserOutput.class, parameterMap);
		LOGGER.info("getNormalizedDataForSUPPLXsl completed with result");
		return parserOutput;
	}

	@Override
	public List<Object> getNormalizedDataOfBanksForXsl(int WqId, int fillingId) {
		LOGGER.info("getNormalizedDataOfBanksForXsl started");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		List<Object> parserOutput = genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getNormalizedDataByFilingIdandStatementTypeOfBanksForXsl,
						ParserOutput.class, parameterMap);
		LOGGER.info("getNormalizedDataForXsl completed with result");
		return parserOutput;
	}

	@Override
	public String getTextDataFromFile(String filePath) throws IOException {
		LOGGER.info("-------------- getTextDataFromFile started -------------------");
		LOGGER.debug("getTextDataFromFile started with" + filePath);
		String fileOutput = UploadUtility.readFile(filePath);
		LOGGER.info("getTextDataFromFile completed with result");
		return fileOutput;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getOrgionalFileNames(String customerId, String wqId) {
		LOGGER.info("-------------- getOrgionalFileNames started -------------------");
		LOGGER.debug("getOrgionalFileNames started with" + customerId);
		Map<String, Object> parameterMapForParserMasterId = new HashMap<String, Object>();
		parameterMapForParserMasterId.put("wqId", Integer.parseInt(wqId.trim()));
		List<Object> parserMasterIdList = genericDaoImpl.findByNamedQuery(NamedQueryName.getParserMasterIdByWqID, WorkQueue.class,parameterMapForParserMasterId);
		Integer parserMasterId =null;
		if(parserMasterIdList!=null && !parserMasterIdList.isEmpty())
    	{
			parserMasterId=Integer.parseInt(parserMasterIdList.get(0).toString());
    	}
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("customerId", Integer.parseInt(customerId));
		parameterMap.put("parserId", parserMasterId);
		List<String> fileNames = (ArrayList<String>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getFileNameByCustomerNParserId,FileUploadModel.class, parameterMap);
		return fileNames;
	}

	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public NormalizeFormData addNormalizedData(NormalizeFormData addData) {
		int result = 0;
		Integer fillingId = addData.getFillingId();
		String statementType = addData.getStatementType();
		Integer wqId = addData.getWqId();
		ParserOutput po = new ParserOutput();
		List<Integer>  addedPoids= null;
		Method  method = null;
		 String nonEnglishLabelFlag="N";
		 Map<String, Object> parameterMap = null;
		 String nonEnglishLabel="";
		 List<LanguageMappingMetadata> lanauageIdList=null;
		 LanguageMappingMetadata languageMappingMetadata= null;
		 String poNormalisedLAbelDetails  = null;
		 String englishLabel="";
		 int count=0;
		 if(addData.getLanguage()!=null && !addData.getLanguage().equalsIgnoreCase("") && !addData.getLanguage().equalsIgnoreCase("English")){
			 nonEnglishLabelFlag = "Y";
		 }
			
		
		
		if (addData.getAddPoLable() != null && addData.getAddSequence() != null) {
			addedPoids=new ArrayList<Integer>();
			for (int i = 0; i < addData.getAddPoLable().size(); i++) {
				poNormalisedLAbelDetails = null;
				if(addData.getAddNormLable()!=null && !addData.getAddNormLable().isEmpty())
				{
					poNormalisedLAbelDetails = addData.getAddNormLable().get(i);
				}
				String[] listOfNiItemAndNilLabel = null;
				if (poNormalisedLAbelDetails != null) {
					listOfNiItemAndNilLabel = poNormalisedLAbelDetails.split("~");
				}

				po = new ParserOutput();
				// ** Set dynamic setter for val1 to 20 col
				Class<?> ParserOutputClone = ParserOutput.class;
				Object obj = null;
				try {
					obj = ParserOutputClone.newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
				if (addData.getAddVal() != null) {
					int valcolCounter = 1;
					for (Map.Entry<String, List<String>> entry : addData.getAddVal().entrySet()) {
						try {
							method = ParserOutputClone.getDeclaredMethod("setPoAsRepVal" + valcolCounter, String.class);
							method.setAccessible(true);
							if(entry.getValue()!=null){
							method.invoke(obj, entry.getValue().isEmpty() ? "" : entry.getValue().get(i).replace("$", "").replace(",", "").toString());
							}
							valcolCounter++;
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					 BeanUtils.copyProperties(obj,po);
				} // end dynamic setter function

				po.setFillingId(fillingId);
				po.setPoSection(statementType);
				po.setWqId(wqId);
				po.setPoCrudAccount("U");
				
				/**
				 * mappingType used for to check mapping is Automated or manual
				 */
				po.setMappingType("MANUAL");
				 po.setRefPoId(addData.getRefPOID()!=null?Integer.parseInt(addData.getRefPOID()):-1);
				if (addData.getAddbrekUps() != null) {
					if (addData.getAddbrekUps().get(i).equalsIgnoreCase("Y")) {
						po.setPoBreakup("Y");
						if(null != addData.getAddbrekUpsRefPoid().get(i) && !addData.getAddbrekUpsRefPoid().get(i).contains("child")){
							po.setRefPoId(addData.getAddbrekUpsRefPoid().get(i)!=null?Integer.parseInt(addData.getAddbrekUpsRefPoid().get(i).trim()):-1);
						}
						 
					} else {
						po.setPoBreakup("N");
					}
				} else {
					po.setPoBreakup("N");
				}

				englishLabel=CollectionUtils.isEmpty(addData.getAddPoLable()) ? "" : addData.getAddPoLable().get(i).replace("Â","");
				po.setPoAsRepLabel(englishLabel);
				
				if(nonEnglishLabelFlag.equals("Y")){
					
					nonEnglishLabel=CollectionUtils.isEmpty(addData.getAddNonEnglishLabel()) ? "" : addData.getAddNonEnglishLabel().get(i);
					
					if(!nonEnglishLabel.equalsIgnoreCase("") && !StringUtils.isEmpty(englishLabel)){
						parameterMap =new HashMap<String, Object>();
						parameterMap.put("nonEnglishLabel", nonEnglishLabel);
						parameterMap.put("language", addData.getLanguage());
						lanauageIdList=(ArrayList<LanguageMappingMetadata>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getLanguageIdByNonEnglishLabel, LanguageMappingMetadata.class, parameterMap);
						
						if(CollectionUtils.isEmpty(lanauageIdList) ){
							languageMappingMetadata = new LanguageMappingMetadata();
							languageMappingMetadata.setEnglishLabel(englishLabel);
							languageMappingMetadata.setNonEnglishLabel(nonEnglishLabel);
							languageMappingMetadata.setLanguage(addData.getLanguage());
							languageMappingMetadata.setSection(statementType);
							genericDaoImpl.persist(languageMappingMetadata);
						}else{
							if(lanauageIdList.size()>1){
								count=1;
								for(LanguageMappingMetadata LanguageMappingMetadataObj : lanauageIdList){
									if(count<lanauageIdList.size()){
										genericDaoImpl.remove(LanguageMappingMetadataObj);
									}
									count++;
								}
							}
							parameterMap.put("englishLabel", englishLabel);
							parameterMap.put("statementType", statementType);
							genericDaoImpl.updateByNamedQuery(NamedQueryName.updateLanguageMappingMetadataByNonEnglishLabel, LanguageMappingMetadata.class, parameterMap);
							
						}
					}
					po.setNonEnglishLable(nonEnglishLabel);
					
					//po.setNonEnglishLable((addData.getAddNonEnglishLabel() == null || addData.getAddNonEnglishLabel().isEmpty()) ? "" : addData.getAddNonEnglishLabel().get(i).replace("Â",""));
				}

				Integer addPoIndexSeq= addData.getAddSequence() == null || addData.getAddSequence().isEmpty() ? 0 : addData.getAddSequence().get(i);
				Integer addPoIndex=setValidPoindexOrder(addPoIndexSeq,fillingId,statementType);	
				po.setPoIndexOrder(addPoIndex);
				po.setPoSubSection(addData.getAddSubSection() == null || addData.getAddSubSection().isEmpty() ? "" : addData.getAddSubSection().get(i));
				po.setAccountNumber(addData.getAddAccountNumber() == null || addData.getAddAccountNumber().isEmpty() ? "": addData.getAddAccountNumber().get(i));
				po.setTimePeriod(addData.getAddTimePeriod() == null || addData.getAddTimePeriod().isEmpty() ? "" : addData.getAddTimePeriod().get(i));
				po.setCustodianName(addData.getAddCustodianName() == null || addData.getAddCustodianName().isEmpty() ? "" : addData.getAddCustodianName().get(i));
				po.setPoSubTotal(addData.getAdSubTotal() == null || addData.getAdSubTotal().isEmpty() ? "" : addData.getAdSubTotal().get(i));
				po.setNote(addData.getAddNote() == null || addData.getAddNote().isEmpty() ? "" : addData.getAddNote().get(i));
				po.setIsDuplicate(addData.getIsDublicate() == null || addData.getIsDublicate().isEmpty() ? "" : addData.getIsDublicate().get(i));
				Integer templateId = getTemplateIdByFilingIdFromFiling(fillingId);
				String normLabel =null;
				if (listOfNiItemAndNilLabel != null && listOfNiItemAndNilLabel.length > 1) {
					if (!listOfNiItemAndNilLabel[0].equalsIgnoreCase("--Select--")) {
						po.setNiItem(listOfNiItemAndNilLabel[0] == null ? 0 : Integer.parseInt(listOfNiItemAndNilLabel[0]));
						try {
							normLabel = getNormItemLabelsByNiItemAndTemplateId(po.getNiItem(),templateId);
						} catch (Exception e) {
							e.printStackTrace();
						}
						po.setNilLabel(normLabel == null ? "" : normLabel);
						po.setNiItemSuggstive(listOfNiItemAndNilLabel[0] == null ? "" : listOfNiItemAndNilLabel[0]);
					}

				}

				LOGGER.info("Add Data" + po.toString());
				genericDaoImpl.persist(po);
				Integer newpoid=po.getPoId();
				addedPoids.add(newpoid);
				
				ParserOutputAuditTrail parserOutputAuditTrailOriginal =getOriginalPORecordToPOATRecord(addData,po);
				if(parserOutputAuditTrailOriginal!=null){
					parserOutputAuditTrailOriginal.setPoCrudStatus("N");
					genericDaoImpl.persist(parserOutputAuditTrailOriginal);
				}
				//if (addNormalizedData(po,parserOutputAudit));
				// selected dublicate row of poid and get poid of record from PO_CORD_HIGHLIGHT_DETAILS clone row  and inserted of  added Po_ids  
				if ( addData.getIsDublicate().get(i).equalsIgnoreCase("Y")) {
				    saveIsDeletedRecords(addData.getAddParentPo_Id().get(i),addData.getAddSequence().get(i),statementType,fillingId);
				}
				
				result += 1;
				List<Integer> poIDList = new ArrayList<Integer>();
				/**
				 * if only one row added then we need to check updatedAllPoList
				 * in not null
				 */
				if (addData.getUpdatedAllPoId() != null) {
					for (Integer poid : addData.getUpdatedAllPoId()) {
						poIDList.add(poid);
					}
				}
				poIDList.add(po.getPoId());
				addData.setAddedAllPoId(addedPoids);
			}

			addData.setAddedrowCount(result);
		}
		return addData;
	}


	private Integer setValidPoindexOrder(Integer startIndex, Integer fillingId, String statementType) {
		Integer endIndex=startIndex+20;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", fillingId);
		parameterMap.put("section", statementType);
		parameterMap.put("startIndex", startIndex);
		parameterMap.put("endIndex", endIndex);
		List<Integer> indexList =(List<Integer>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNextSequencesByIndexSeq, ParserOutput.class,parameterMap);
		 if(!CollectionUtils.isEmpty(indexList)){
				for(Integer indexOrder :indexList){
						if (indexList.contains(startIndex)) {
							startIndex = startIndex + 1;
						} else {
							break;
						}	
				}
		 }
		return  startIndex;
	}

	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	private void saveIsDeletedRecords(String parentPoid, Integer isDeletedPoIndex,String statementType,Integer fillingId) {
		List<Object>  parserOutputPo_Ids =null;
		List<Integer>  newPoId =null;
		POCordHighlightDetails phd=null;
		try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poIndexOrder", isDeletedPoIndex);
		parameterMap.put("poSection", statementType);
		parameterMap.put("filingId", fillingId);
		parameterMap.put("poId", Integer.parseInt(parentPoid));
	  
		//1  getting Po_id of new Inserted
		parserOutputPo_Ids = genericDaoImpl.findByNamedQuery(NamedQueryName.getParserOutputByPoIndexOrder,
						ParserOutput.class, parameterMap);
		for(Object object:parserOutputPo_Ids){
			newPoId=new ArrayList<Integer>();
			newPoId.add(object!=null ? Integer.parseInt(object.toString()) :0);
		}
		// 2 getting POCordHighlightDetails of new Inserted
		phd=genericDaoImpl.findByColumn(NamedQueryName.getCordinateDetails, POCordHighlightDetails.class, parameterMap);
		POCordHighlightDetails insertPhd=null;
		if(phd!=null && newPoId!=null){
			Integer newPoid =newPoId.get(0);
			insertPhd=new POCordHighlightDetails();
			insertPhd.setpoId(newPoid);
			insertPhd.setOpSection(phd.getOpSection());
			insertPhd.setFilingID(phd.getFilingID());
			insertPhd.setCordDetailsVal1(phd.getCordDetailsVAL1());
			insertPhd.setCordDetailsVAL2(phd.getCordDetailsVAL2());
			insertPhd.setCordDetailsVAL3(phd.getCordDetailsVAL3());
			insertPhd.setCordDetailsVAL4(phd.getCordDetailsVAL4());
			insertPhd.setCordDetailsVAL5(phd.getCordDetailsVAL5());
			insertPhd.setCordDetailsVAL6(phd.getCordDetailsVAL6());
			insertPhd.setCordDetailsVAL7(phd.getCordDetailsVAL7());
			insertPhd.setCordDetailsVAL8(phd.getCordDetailsVAL8());
			insertPhd.setCordDetailsVAL9(phd.getCordDetailsVAL9());
			insertPhd.setCordDetailsVAL10(phd.getCordDetailsVAL10());
			insertPhd.setCordDetailsVAL11(phd.getCordDetailsVAL11());
			insertPhd.setCordDetailsVAL12(phd.getCordDetailsVAL12());
			insertPhd.setCordDetailsVAL13(phd.getCordDetailsVAL13());
			insertPhd.setCordDetailsVAL14(phd.getCordDetailsVAL14());
			insertPhd.setCordDetailsVAL15(phd.getCordDetailsVAL15());
			insertPhd.setCordDetailsVAL16(phd.getCordDetailsVAL16());
			insertPhd.setCordDetailsVAL17(phd.getCordDetailsVAL17());
			insertPhd.setCordDetailsVAL18(phd.getCordDetailsVAL18());
			insertPhd.setCordDetailsVAL19(phd.getCordDetailsVAL19());
			insertPhd.setCordDetailsVAL20(phd.getCordDetailsVAL20());
			genericDaoImpl.persist(insertPhd);
		}
		}catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:", e);
		}	
	}
	
	
	
	@SuppressWarnings({ "unchecked" })
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public NormalizeFormData updateNormalizedData(NormalizeFormData updData,String isChild) {

		int result = 0;
		Integer fillingId = updData.getFillingId();
		String statementType = updData.getStatementType();
		Integer wqId = updData.getWqId();
		ParserOutput po = new ParserOutput();
		boolean nonEnglishFlag=false;
		boolean isAttrLabelUpdate = false;
		String nonEnglishLabelFlag="N";
		Map<String, Object> parameterMap = null;
		String nonEnglishLabel="";
		List<LanguageMappingMetadata> lanauageIdList=null;
		LanguageMappingMetadata languageMappingMetadata= null;
		String poNormalisedLAbelDetails  = null;
		String englishLabel="";
		int count=0;
		if(updData.getLanguage()!=null && !updData.getLanguage().equalsIgnoreCase("") && !updData.getLanguage().equalsIgnoreCase("English")){
			 nonEnglishLabelFlag = "Y";
		 }
		
		if (updData.getUpdPoId() != null ) {
			for (int i = 0; i < updData.getUpdPoId().size(); i++) {
				nonEnglishFlag=false;
				
				if(!CollectionUtils.isEmpty(updData.getUpdNormLable()))
				{
					poNormalisedLAbelDetails = updData.getUpdNormLable().get(i);
				}
				
				String[] listOfNiItemAndNilLabel = null;
				if (poNormalisedLAbelDetails != null) {
					listOfNiItemAndNilLabel = poNormalisedLAbelDetails.split("~");
				}

				po = new ParserOutput();
				po.setFillingId(fillingId);
				po.setPoSection(statementType);
				po.setPoCrudAccount("U");
				po.setMappingType("MANUAL");
				englishLabel=CollectionUtils.isEmpty(updData.getUpdPoLable()) ? "" : updData.getUpdPoLable().get(i).replace("Ã‚","");
				if(nonEnglishLabelFlag.equals("Y")){
					
					nonEnglishFlag=true;
					nonEnglishLabel=CollectionUtils.isEmpty(updData.getUpdNonEnglishLabel()) ? "" : updData.getUpdNonEnglishLabel().get(i);
					
					if(!nonEnglishLabel.equalsIgnoreCase("") && !englishLabel.equalsIgnoreCase("")){
						parameterMap =new HashMap<String, Object>();
						parameterMap.put("nonEnglishLabel", nonEnglishLabel);
						parameterMap.put("language", updData.getLanguage());
						lanauageIdList=(ArrayList<LanguageMappingMetadata>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getLanguageIdByNonEnglishLabel, LanguageMappingMetadata.class, parameterMap);
						
						if(CollectionUtils.isEmpty(lanauageIdList) ){
							languageMappingMetadata = new LanguageMappingMetadata();
							languageMappingMetadata.setEnglishLabel(englishLabel);
							languageMappingMetadata.setNonEnglishLabel(nonEnglishLabel);
							languageMappingMetadata.setLanguage(updData.getLanguage());
							languageMappingMetadata.setSection(statementType);
							genericDaoImpl.persist(languageMappingMetadata);
						}else{
							if(lanauageIdList.size()>1){
								count=1;
								for(LanguageMappingMetadata LanguageMappingMetadataObj : lanauageIdList){
									if(count<lanauageIdList.size()){
										genericDaoImpl.remove(LanguageMappingMetadataObj);
									}
									count++;
								}
							}
							parameterMap.put("englishLabel", englishLabel);
							parameterMap.put("statementType", statementType);
							genericDaoImpl.updateByNamedQuery(NamedQueryName.updateLanguageMappingMetadataByNonEnglishLabel, LanguageMappingMetadata.class, parameterMap);
							
						}
					}
					po.setNonEnglishLable(nonEnglishLabel);
					
					
				}
				po.setWqId(wqId);

				if (updData.getUpbrekUps() != null) {
					if (updData.getUpbrekUps().get(i).equalsIgnoreCase("Y")) {
						po.setPoBreakup("Y");
					} else {
						po.setPoBreakup("N");
					}
				} else {
					po.setPoBreakup("N");
				}

				po.setPoAsRepLabel(englishLabel);
/**
 * Start 
 * Here wet dynamic column and values
 * eg:po_val1="123"
 * po_val2="abc"
 */
 Map<String,String> poValColMap=new LinkedHashMap<String,String>();
if(updData.getUpdVal()!=null){
int colSequnece=1; 


for (Map.Entry<String, List<String>> entry : updData.getUpdVal().entrySet()) {
	        System.out.println(entry.getKey() + " - " + entry.getValue());
	        poValColMap.put("poAsRepVal"+colSequnece, entry.getValue()==null || entry.getValue().isEmpty() ? "" : entry.getValue().get(i));
	        colSequnece++;
  }
po.setPo_valColMap(poValColMap);
}
//end		
		
				po.setPoIndexOrder(updData.getUpdSequence() == null
						|| updData.getUpdSequence().isEmpty() ? 0 : updData
						.getUpdSequence().get(i));
				po.setNote(updData.getUpdNote() == null
						|| updData.getUpdNote().isEmpty() ? "" : updData
						.getUpdNote().get(i));
				
				if (listOfNiItemAndNilLabel != null
						&& listOfNiItemAndNilLabel.length > 1) {
					po.setNiItem(listOfNiItemAndNilLabel[0] == null ? 0
							: Integer.parseInt(listOfNiItemAndNilLabel[0]));
					po.setNilLabel(listOfNiItemAndNilLabel[1] == null ? ""
							: listOfNiItemAndNilLabel[1]);
					po.setNiItemSuggstive(listOfNiItemAndNilLabel[0] == null ? ""
							: listOfNiItemAndNilLabel[0]);
				}
				po.setPoSubSection(updData.getUpdSubSection() == null
						|| updData.getUpdSubSection().isEmpty() ? "" : updData
						.getUpdSubSection().get(i));

				po.setAccountNumber(updData.getUpdAccountNumber() == null
						|| updData.getUpdAccountNumber().isEmpty() ? ""
						: updData.getUpdAccountNumber().get(i));
				po.setTimePeriod(updData.getUpdTimePeriod() == null
						|| updData.getUpdTimePeriod().isEmpty() ? "" : updData
						.getUpdTimePeriod().get(i));
				po.setCustodianName(updData.getUpdCustodianName() == null
						|| updData.getUpdCustodianName().isEmpty() ? ""
						: updData.getUpdCustodianName().get(i));
				po.setPoSubTotal(updData.getUpSubTotal() == null
						|| updData.getUpSubTotal().isEmpty() ? "" : updData
						.getUpSubTotal().get(i));
				po.setPoId(updData.getUpdPoId().get(i));
				LOGGER.info("Update Data" + po.toString());
				
				/**
				 * Here we fetch old ParserOutput object based on poid and compare it to new one
				 * if any changes will find then we will insert into
				 * one new entry in parser_output table for maintaining old record
				 */
				ParserOutput parserOutputOld=qaMessageChecklistService.getRecordUsingPOID(po.getPoId());
				String suggestive = parserOutputOld.getNiItemSuggstive();
				if(suggestive!=null && suggestive.length()>0 && (suggestive.split(",")).length>1)
				{
					po.setMappingType("MANUAL-Suggestive");
				}
					
				/**
				 * This function is used for compare two parseroutput object 
				 */
				if(!isAnychangesFromUI(po,parserOutputOld)){
				
				/**
				 * Here we check is label from statement_attribute and section
				 * from IS.
				 */
				/**
				 *Here isAttrLabelUpdate flag used for
				 *if updated as_rep_label from 	STATEMENT YEAR,STATEMENT Month,STATEMENT Date,STATEMENT period
				 *we need to update Statment month and period column from work_queue table
				 */
				
				ParserOutputAuditTrail parserOutputAuditTrailOriginal =getOriginalPORecordToPOATRecord(updData,po.getPoId());
				
				
				if (!isAttrLabelUpdate) {
					if (po.getPoAsRepLabel().equalsIgnoreCase("STATEMENT YEAR")
							|| po.getPoAsRepLabel().equalsIgnoreCase(
									"STATEMENT MONTH")
							|| po.getPoAsRepLabel().equalsIgnoreCase(
									"STATEMENT DATE")
							|| po.getPoAsRepLabel().equalsIgnoreCase(
									"STATEMENT PERIOD")) {
						isAttrLabelUpdate = true;
					}
					if(parserOutputAuditTrailOriginal!=null){
						parserOutputAuditTrailOriginal.setIsExtraction("Y");
					}
					
				}
				
				if (po.getPoAsRepLabel().equalsIgnoreCase("STATEMENT YEAR") || po.getPoAsRepLabel().equalsIgnoreCase("STATEMENT MONTH")	|| po.getPoAsRepLabel().equalsIgnoreCase(
								"STATEMENT DATE") || po.getPoAsRepLabel().equalsIgnoreCase("STATEMENT PERIOD")) {
					if(parserOutputAuditTrailOriginal!=null){
						parserOutputAuditTrailOriginal.setIsExtraction("Y");
					}
			
				}
				
				/**
				 * Here we insert new entry in parser_output_audit_trail table and parser_output table
				 */
				if(parserOutputAuditTrailOriginal!=null){
					parserOutputAuditTrailOriginal.setPoCrudStatus("O");
					genericDaoImpl.persist(parserOutputAuditTrailOriginal);
				}
				
				/**
				 * Here we update parser_output records  poAsRepVal
				 */
				String keyVal="poAsRepVal";
				Field targetField=null;
				boolean accessible=false;
				try{
					if(!CollectionUtils.isEmpty(poValColMap)){
						for(int j=1;j<=poValColMap.size();j++){
							keyVal="poAsRepVal";
							keyVal=keyVal+j;
							targetField = ParserOutput.class.getDeclaredField(keyVal);
							accessible = targetField.isAccessible();
							targetField.setAccessible(true);
							targetField.set(po,  poValColMap.get(keyVal));
						
							targetField.setAccessible(accessible);
						
						}
					}
				}catch(Exception e){
					e.printStackTrace();
				}
				
				result += UpdatedeleteParserOutput(po, 2,nonEnglishFlag); //TO DO Prasad
				System.out.println(poValColMap);
				
				ParserOutputAuditTrail parserOutputAuditTrailNew = getOriginalPORecordToPOATRecord(updData,po);
				
				
				StringBuilder sb = new StringBuilder("");
				String colName="PO_VAL";
				if(parserOutputAuditTrailNew!=null && parserOutputAuditTrailOriginal!=null){
					
					if(!parserOutputAuditTrailNew.getArsLabel().trim().equals(parserOutputAuditTrailOriginal.getArsLabel().trim())){
						sb.append("PO_AS_REP_LABEL,");
					}
					
					try{
						
						Method sourceFieldStr = null;
						Method targetFieldStr = null;
						String tempSource="";
						String tempTarget=""; 
						if(!CollectionUtils.isEmpty(poValColMap)){
							keyVal="getPoVal";
							for(int j=1;j<=poValColMap.size();j++){
								keyVal="getPoVal";
								keyVal=keyVal+j;
								sourceFieldStr =ParserOutputAuditTrail.class.getMethod(keyVal);
								targetFieldStr =ParserOutputAuditTrail.class.getMethod(keyVal);
								tempSource=sourceFieldStr.invoke(parserOutputAuditTrailOriginal)!=null?sourceFieldStr.invoke(parserOutputAuditTrailOriginal).toString():"";
								tempTarget=targetFieldStr.invoke(parserOutputAuditTrailNew)!=null?targetFieldStr.invoke(parserOutputAuditTrailNew).toString():"";
								if(!tempSource.equalsIgnoreCase(tempTarget)){
									sb.append(colName).append(j).append(",");
								}
							
							}
						}
					}catch(Exception e){
						e.printStackTrace();
					}
					
					
					
					if(parserOutputAuditTrailNew.getNiItem()!=null && parserOutputAuditTrailNew.getNilLabel()!=null){
						if(!parserOutputAuditTrailNew.getNiItem().equals(parserOutputAuditTrailOriginal.getNiItem()) && !parserOutputAuditTrailNew.getNilLabel().trim().equals(parserOutputAuditTrailOriginal.getNilLabel().trim())){
							
							sb.append("NI_ITEM,NIL_LABEL,");
						}
					}
					
					if(!parserOutputAuditTrailNew.getBreakup().equals(parserOutputAuditTrailOriginal.getBreakup())){
						sb.append("PO_BREAKUP,");
					}
					if(!parserOutputAuditTrailNew.getPoIndexOrder().equals(parserOutputAuditTrailOriginal.getPoIndexOrder())){
						sb.append("PO_INDEX_ORDER,");
					}
					
					if(isChild.equals("N")){
						if(!parserOutputAuditTrailNew.getPoNote().equals(parserOutputAuditTrailOriginal.getPoNote())){
							sb.append("PO_NOTE,");
						}
					}
					
					if(!parserOutputAuditTrailNew.getPoSubSection().equals(parserOutputAuditTrailOriginal.getPoSubSection())){
						sb.append("PO_SUBSECTION,");
					}
					if(sb.toString().length()>0){
						parserOutputAuditTrailNew.setCategory(sb.toString().substring(0,sb.toString().length()-1));
					}else{
						parserOutputAuditTrailNew.setCategory("");
					}
					
					parserOutputAuditTrailNew.setPoCrudStatus("U");
					genericDaoImpl.persist(parserOutputAuditTrailNew);
					
				}

				
			}
			updData.setUpdatedrowCount(result);
			/**
			 * if updated row label from statement year,statement
			 * month,statement date and statement period then update
			 * WQ_MONTH_YEAR and WQ_PERIOD from work_queue table with highest
			 * date and period
			 */
			if (isAttrLabelUpdate && (statementType.equalsIgnoreCase("IS") || statementType.equalsIgnoreCase("DOS"))) {
				 updateWorkQueueForMonthAndYear(fillingId,statementType);
			}
		}//end for
     }//end isAnychangesFromUI() function.
		return updData;
	}

	public int UpdatedeleteParserOutput(ParserOutput po, int flag,boolean nonEnglishFlag) {
		int updRow = 0;
 		HashMap<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("poId", po.getPoId());
		parameters.put("fillingId", po.getFillingId());
		
		parameters.put("poCrud", po.getPoCrudAccount());
		parameters.put("poSection", po.getPoSection());
	
		if (flag == 2)// Update for DB --
		{
			try {
				updRow=normalizationViewDAO.f_updateParserOutputByDynamicColValues(po,nonEnglishFlag);
			} catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error in update parseroutoput:",e);
			}
			
		}

		LOGGER.info("Parser Output Data" + parameters.toString());
		switch (flag) {
		case 1:// flag 1 used for Delete statement
			updRow = genericDaoImpl
					.updateByNamedQuery(
							NamedQueryName.updateNormalizedDataViewFlagByPoIdFillingIdWqIdStatementType,
							ParserOutput.class, parameters);
			break;
		}
		return updRow;
	}
	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public NormalizeFormData deleteNormalizeData(NormalizeFormData delData) {

		Integer fillingId = delData.getFillingId();
		Integer wqId = delData.getWqId();
		ParserOutput po = new ParserOutput();
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		Set<Integer> poIdSet = new HashSet<Integer>();
		if (delData.getDelPoId() != null) {
			for (int i = 0; i < delData.getDelPoId().size(); i++) {
				poIdSet.add(delData.getDelPoId().get(i));
				po = new ParserOutput();
				po.setPoId(delData.getDelPoId().get(i));
				po.setFillingId(fillingId);
				po.setPoCrudAccount("D");
				po.setWqId(wqId);// NOT REQUIRED Not updated from rage side in
									// db
				po.setPoSection(delData.getStatementType());
				/**
				 * Here we set parser_output_audit object values
				 */
				
			//code for delete po_ids by  >>>>>>   ' ref_poids =  po_ids '
				
				HashMap<String, Object> parameters = new HashMap<String, Object>();
				parameters.put("poId", delData.getDelPoId().get(i));
				parameters.put("fillingId",fillingId);
				
				List<Integer> refPoidList = (ArrayList<Integer>) (Object) (genericDaoImpl
						.findByNamedQuery(NamedQueryName.getRefPoidsList, ParserOutput.class, parameters));
		if (refPoidList != null && refPoidList.size()>0) {
					HashMap<String, Object> deleteRefpoids = new HashMap<String, Object>();
					deleteRefpoids.put("poId", refPoidList);
					deleteRefpoids.put("fillingId", fillingId);
					deleteRefpoids.put("poCrud", "D");
					int updRefPoids = genericDaoImpl.updateByNamedQuery(
							NamedQueryName.updateNormalizedDataViewFlagByPoIdFillingIdWqIdStatementType,
							ParserOutput.class, deleteRefpoids);
					if (updRefPoids > 0) {
						for (int j = 0; j < refPoidList.size(); j++) {
							ParserOutputAuditTrail parserOutputAuditTrailNew = getOriginalPORecordToPOATRecord(delData,
									refPoidList.get(j));
							if (parserOutputAuditTrailNew != null) {
								parserOutputAuditTrailNew.setPoCrudStatus("D");
								genericDaoImpl.persist(parserOutputAuditTrailNew);
							}
						}
					}

				}
				//end for delete po_ids by  ref_poids equals  po_ids
				
				
				UpdatedeleteParserOutput(po, 1,false);// flag 1 for update
															// delete query;
				ParserOutputAuditTrail parserOutputAuditTrailNew =getOriginalPORecordToPOATRecord(delData,po.getPoId());
				if(parserOutputAuditTrailNew!=null){
					parserOutputAuditTrailNew.setPoCrudStatus("D");
					genericDaoImpl.persist(parserOutputAuditTrailNew);
				}
				
			}
			
			parameterMap.put("poId",poIdSet);
			
			List<ArsPoMapping> arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
					.findByNamedQuery(NamedQueryName.getArsPoMappingRecordByPOID,
							ArsPoMapping.class, parameterMap);
			
			List<NIValues> niValuesRecordList=null;
			Map<String, Object> NIValueparameterMap = null;
			if(arsPoMappingRecordList!=null ){
				for(ArsPoMapping arsPoMappingRecord :arsPoMappingRecordList){
					NIValueparameterMap = new HashMap<String, Object>();
					NIValueparameterMap.put("arsId", arsPoMappingRecord.getArsId());
					NIValueparameterMap.put("fillingId", arsPoMappingRecord.getFillingId());
					NIValueparameterMap.put("niItem", arsPoMappingRecord.getNiItem());
					niValuesRecordList = (ArrayList<NIValues>) (Object) genericDaoImpl
							.findByNamedQuery(NamedQueryName.getNiValauesRecordByFILID,
									NIValues.class, NIValueparameterMap);
					
					if(niValuesRecordList!=null && niValuesRecordList.size()>0){
						NIValues nIValueRecord = niValuesRecordList.get(0);
						NIValueparameterMap = new HashMap<String, Object>();
						NIValueparameterMap.put("niValue", nIValueRecord.getNiValue().subtract(new BigDecimal(arsPoMappingRecord.getPoColumnVal())));
						NIValueparameterMap.put("niId", nIValueRecord.getNiId());
						
						String selectedPoId = arsPoMappingRecord.getPoId().toString();
						String [] rfPoIdArray = null;
						String refPoIdString = "";
						if(nIValueRecord.getRefPoId()!=null && !nIValueRecord.getRefPoId().equalsIgnoreCase(""))
						{
							rfPoIdArray = nIValueRecord.getRefPoId().split(",");
							if(rfPoIdArray!=null && rfPoIdArray.length>0)
							{
								for (String selecteRefPoId : rfPoIdArray) 
								{
									if (!selecteRefPoId.contains(selectedPoId)) 
									{
										if(refPoIdString!="")
										{
											refPoIdString = refPoIdString+","+selecteRefPoId;
										}
										else
										{
											refPoIdString=selecteRefPoId;
										}
									}
								}
							}
							NIValueparameterMap.put("refPoId", refPoIdString);
						}else{
							NIValueparameterMap.put("refPoId", null);
						}
						genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNIValueColumnByNIID, NIValues.class, NIValueparameterMap);
					}
				}
				genericDaoImpl.remove(arsPoMappingRecordList);
			}
		}
		return delData;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<NormItemLabels> getListOfNormItemLabels(String stmtFormat,
			Integer fillingId) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("section", stmtFormat);
		Map<String, Object> parameterMapOne = new HashMap<String, Object>();
		parameterMapOne.put("filingId", fillingId);
		LOGGER.info("-------------- getListOfNormItemLabels started -------------------");
		Filings templateId = genericDaoImpl.findByColumn(
				NamedQueryName.getTemplateId, Filings.class, parameterMapOne);
		parameterMap.put("templateId", templateId.getTemplateId());
		List<NormItemLabels> normItemLabelsList = null;
		if (templateId.getTemplateId() != null)
			normItemLabelsList = (ArrayList<NormItemLabels>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNormItemLabelsListByTemplate,NormItemLabels.class, parameterMap);
		LOGGER.info("-------------- getOrgionalFileNames ended -------------------");
		return normItemLabelsList;
	}

	@Override
	public Map<String, List<String>> getHeaderDetails(Integer filingId,Integer customerId, Integer wqId,String section,boolean isClientData) {
		LOGGER.info("-------------- getHeaderDetails started -------------------");
		HashMap<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("filingId", filingId);
		
		List<Object> listOfNormalisedLabels = null;
		listOfNormalisedLabels = genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getAsRepStatementDetailsByFilingId,AsRepStatement.class, parameters);
	
		List<String> listOfStatementDates = new ArrayList<String>();
		List<String> listOfPeriods = new ArrayList<String>();
		List<String> auditFlagList  = new ArrayList<String>();
		List<String> qualityList  = new ArrayList<String>();
		List<String> arsIdList  = new ArrayList<String>();
		Map<String, List<String>> mapOfHeaderDetails = new LinkedHashMap<String, List<String>>();

		for (Object object : listOfNormalisedLabels) {
			Object[] objIn = (Object[]) object;
			listOfStatementDates.add(objIn[0]!=null?objIn[0].toString():"");
			listOfPeriods.add(objIn[1]!=null?objIn[1].toString():"");
			auditFlagList.add(objIn[2]!=null?objIn[2].toString():"");
			arsIdList.add(objIn[3]!=null?objIn[3].toString():"");
			qualityList.add(objIn[5]!=null?objIn[5].toString():"");
		}
		
		
		mapOfHeaderDetails.put("Statement Date", listOfStatementDates);
		mapOfHeaderDetails.put("Periods", listOfPeriods);
		mapOfHeaderDetails.put("Statement Type", auditFlagList);
		mapOfHeaderDetails.put("Quality", qualityList);
	
		if(isClientData)
		{
		List<String> lsSourceTypeList=new ArrayList<>();
    	List<String> clientSourceTypeList=new ArrayList<>();
    	List<String> lsClientBothList=new ArrayList<>();	
		for(int j=0;j<listOfNormalisedLabels.size();j++)
		{
			lsSourceTypeList.add("LS");
			clientSourceTypeList.add("Client");
		}
		lsClientBothList.addAll(lsSourceTypeList);
		lsClientBothList.addAll(clientSourceTypeList);
		mapOfHeaderDetails.put("Source Type", lsClientBothList);
		}//end client data
		mapOfHeaderDetails.put("arsId", arsIdList);
		
		LOGGER.info("-------------- getHeaderDetails ended -------------------");
		return mapOfHeaderDetails;
	}

@Override
	public Map<String, List<NormalisedLabelAndValues>> getNormalzedLabelsDetails(Integer fillingId, Integer customerId, Integer wqId,Map<String, List<String>> mapOfHeaders) 
		{
			LOGGER.info("-------------- getNormalzedLabelsDetails started -------------------");
			HashMap<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("filingId", fillingId);
			List<Object> listOfNormalisedLabels = genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getNormItemLabelsAndValuesWithPoRefIds, NormItemLabels.class, parameters);
			NormalizedDetails normalizedDetails;
			Integer templateId = null;
			//List<String> str_Headerlist = mapOfHeaders.get("Statement Date");
			List<String> str_Headerlist = mapOfHeaders.get("arsId");
			List<String> arsIdList = mapOfHeaders.get("arsId");
			List<NormalizedDetails> listOfNormalisedDetails = new ArrayList<NormalizedDetails>();
			Set<String> listOfSections = new LinkedHashSet<String>();
			String mValu = "";
			String[] poIdArray = null;
			String clickBackDetailsString = "";
			Integer selectedPoId = null;
			int indentationDeptNumber=0;
			StringBuilder tempStr=null;
			List<String> poIdCoordinateList = new ArrayList<>();
			List<NormalizedDetails> listOfNormalisedDetailsNew = new ArrayList<>();
			String fileType= "PDF";
			Set<Integer> poIdSet = new HashSet<Integer>();
			String[] poIdListArry = null;
			Map<Integer,ParserOutputCommand> poIdArsLabelMap = null;
			StringBuilder asRepLabelString = null;
			String asRepLabel=null;
			String[] refPoIdArray = null;
			BigDecimal poArsSumValue = null;
			Method  method = null;
			String column = null;
			Object objectValue = null;
			Class<?> poCordHighlightDetailsClass = null;
			Class<?> parserOutputClass =null;
			ValueCommand valueCommand = null;
			try {
				poCordHighlightDetailsClass = Class.forName("com.livespread.domain.POCordHighlightDetails");
				parserOutputClass = Class.forName("com.livespread.command.ParserOutputCommand");
			} catch (ClassNotFoundException e1) {
				e1.printStackTrace();
			}
			if(listOfNormalisedLabels!=null && !listOfNormalisedLabels.isEmpty())
				{
				
				poIdArsLabelMap = getPoIdArsLabelMapByFilingIdAndRefPoIdIsNotNull(fillingId);
				
				for (Object object : listOfNormalisedLabels) {
					Object[] objIn = (Object[]) object;
					normalizedDetails = new NormalizedDetails();
					templateId=objIn[0] == null ? 0 : Integer.parseInt(objIn[0].toString());
					normalizedDetails.setNiItem(objIn[1] == null ? 0 : Integer.parseInt(objIn[1].toString()));
					normalizedDetails.setDate(objIn[2] == null ? "" : objIn[2].toString());
					mValu=objIn[4] == null ? "-" : objIn[4].toString();
					try{
					double values = Double.parseDouble(mValu);
					mValu=decimalFormat.format(values);
					}catch(NumberFormatException nfe){
						LOGGER.error(nfe.getMessage());
					}
					normalizedDetails.setValue(mValu);
					normalizedDetails.setLabel(objIn[5] == null ? "" : objIn[5].toString());
					normalizedDetails.setHeader(objIn[6] == null ? "" : objIn[6].toString());
					normalizedDetails.setDisplayFormat(objIn[7] == null ? "" : objIn[7].toString());
					normalizedDetails.setSection(objIn[8] == null ? "" : objIn[8].toString());
					normalizedDetails.setArsDate(objIn[10] == null ? null : (Date) objIn[10]);
					normalizedDetails.setArs_period(objIn[11] == null ? 0 : Integer.parseInt(objIn[11].toString()));
					normalizedDetails.setArsId(objIn[17] == null ? null : Integer.parseInt(objIn[17].toString()));
					if(objIn[12]!=null && !objIn[12].toString().isEmpty())
					{
						poIdArray = objIn[12].toString().split(",");
						if(poIdArray!=null && poIdArray.length>0)
						{
							try {
								poArsSumValue = new BigDecimal(0);
								Map<Integer,ValueCommand> labelAndValueMap=new LinkedHashMap<>();
								
								for(int i=0;i<poIdArray.length;i++)
								{
									poIdListArry =poIdArray[i].split("-");
									if(poIdListArry!=null && poIdListArry.length == 2)
									{
										poIdSet.add(new Integer(poIdListArry[0]));
										column = poIdListArry[1];
										column = column.replace("PO_VAL", "");
										method = parserOutputClass.getDeclaredMethod ("getPoAsRepVal"+column);
										if(poIdArsLabelMap !=null && !poIdArsLabelMap.isEmpty() && poIdArsLabelMap.containsKey(new Integer(poIdListArry[0])))
										{
											ParserOutputCommand command=poIdArsLabelMap.get(new Integer(poIdListArry[0]));
											objectValue = method.invoke (poIdArsLabelMap.get(new Integer(poIdListArry[0])));
											if(objectValue!=null && !objectValue.toString().isEmpty())
											{
												String value = null;
												if(isDoubleValue(objectValue.toString().trim()))
												{
													value = objectValue.toString().trim().replace(",", "");
													valueCommand = new ValueCommand();
													valueCommand.setAsRepLabel(command.getPoAsRepLabel());
													valueCommand.setValue(value);
													labelAndValueMap.put(command.getPoId(), valueCommand);
													poArsSumValue = poArsSumValue.add(new BigDecimal(value));
												}
											}
										}
									}
								}//end po_ref_id for loop
								normalizedDetails.setLabelAndValueMap(labelAndValueMap);
								
								int result = poArsSumValue.compareTo(new BigDecimal(normalizedDetails.getValue().replaceAll(",", "")));
								if(result == 0)
								{
									normalizedDetails.setIsValueMatch("Y");
								}
								else
								{
									normalizedDetails.setIsValueMatch("N");
								}
							} catch (NumberFormatException e) {
								e.printStackTrace();
							} catch (NoSuchMethodException e) {
								e.printStackTrace();
							} catch (SecurityException e) {
								e.printStackTrace();
							} catch (IllegalAccessException e) {
								e.printStackTrace();
							} catch (IllegalArgumentException e) {
								e.printStackTrace();
							} catch (InvocationTargetException e) {
								e.printStackTrace();
							}
							normalizedDetails.setIsRefPoId("Y");
							if(poIdArray.length==1)
							{
								normalizedDetails.setIsMultiRefPoId("N");
								normalizedDetails.setCoordinateDetailsString(poIdArray[0].toString());
								clickBackDetailsString = poIdArray[0];
								if(clickBackDetailsString!=null && !clickBackDetailsString.isEmpty())
								{
									poIdCoordinateList.add(clickBackDetailsString);
									selectedPoId = Integer.parseInt(clickBackDetailsString.split("-")[0].toString());
									normalizedDetails.setPoId(selectedPoId);
								}
								else
								{
									normalizedDetails.setClickbackExists("N");
								}
							}
							else
							{
								refPoIdArray=objIn[12].toString().split(",");
								if(refPoIdArray!=null && refPoIdArray.length>0)
								{
									asRepLabelString = new StringBuilder();
									for(int i=0;i<refPoIdArray.length;i++)
									{
										poIdListArry =refPoIdArray[i].split("-");
										if(poIdListArry!=null && poIdListArry.length == 2 && poIdArsLabelMap.containsKey(new Integer(poIdListArry[0])))
										{
											asRepLabel = poIdArsLabelMap.get(new Integer(poIdListArry[0])).getPoAsRepLabel();
											if(asRepLabel!=null && !asRepLabel.isEmpty())
											{
												if(asRepLabelString.length()>0)
												{
												asRepLabelString.append(", "+asRepLabel);
												}
												else
												{
													asRepLabelString.append(asRepLabel);
												}
											}
										}
									}
									normalizedDetails.setAsRepLabel(asRepLabelString.toString());
								}
								normalizedDetails.setIsMultiRefPoId("Y");
							}
						}
						else
						{
							normalizedDetails.setIsRefPoId("N");
						}
					}
					else
					{
						normalizedDetails.setIsRefPoId("N");
					}
					normalizedDetails.setNivId(objIn[13] == null ? 0 : Integer.parseInt(objIn[13].toString()));
					normalizedDetails.setAccountId(objIn[14] == null ? "" : objIn[14].toString());
					normalizedDetails.setAccountDisplayLongDs(objIn[15] == null ? "" : objIn[15].toString());
					indentationDeptNumber=objIn[16] == null ? 0 : Integer.parseInt(objIn[16].toString());
					normalizedDetails.setDisplaySequence(objIn[9] == null ? 0 : Integer.parseInt(objIn[9].toString()));
					normalizedDetails.setCategory(objIn[18] == null ? "" : objIn[18].toString());
					normalizedDetails.setSourceData(objIn[19] == null ? "LS" : objIn[19].toString());
					tempStr=new StringBuilder("");
					for(int i =0;i<indentationDeptNumber;i++)
					{
						tempStr.append("&nbsp;&nbsp;");
					}
					normalizedDetails.setLabelHierarchy(tempStr.toString());
					
					if (normalizedDetails.getPoId() == null)
					{
							listOfNormalisedDetails.add(normalizedDetails);
					}
					else
					{
						listOfNormalisedDetailsNew.add(normalizedDetails);
					}
					listOfSections.add(objIn[8] == null ? "" : objIn[8].toString());
				}
			}
			
			List<Integer> selectedPoIdList = null;
			Map<Integer, POCordHighlightDetails> poCordHighlightMap = null;
			if(poIdCoordinateList!=null && !poIdCoordinateList.isEmpty())
			{
				selectedPoIdList = new ArrayList<>();
				for (String selectePoidColDetails : poIdCoordinateList) 
				{
					selectedPoIdList.add(Integer.parseInt(selectePoidColDetails.split("-")[0].toString()));
				}
				try {
					poCordHighlightMap = poCordHighlightDetailsService.getCoordinateDetailsMap(selectedPoIdList);
				} catch (Exception e) {
					e.printStackTrace();
				}	
				String poIdColDetailsString = null;
				Integer poId = null;
				String coordinateColumn = null;
				POCordHighlightDetails poCordHighlightDetails = null;

					try {
				    	Integer uploadId = null;
						Integer oldUploadId = null;
						for (NormalizedDetails selectedNormalizedDetails  : listOfNormalisedDetailsNew) 
							{
								uploadId = null;
								poIdColDetailsString =selectedNormalizedDetails.getCoordinateDetailsString();
								poId = Integer.parseInt(poIdColDetailsString.split("-")[0]);
								coordinateColumn = poIdColDetailsString.split("-")[1].toString();
								column = coordinateColumn.replace("PO_VAL", "VAL");
								coordinateColumn = coordinateColumn.replace("PO_VAL", "val");
								if( poCordHighlightMap!=null && !poCordHighlightMap.isEmpty() && poCordHighlightMap.containsKey(poId))
								{
									poCordHighlightDetails = poCordHighlightMap.get(poId);
									method = poCordHighlightDetailsClass.getDeclaredMethod ("getCordDetails"+column);
									objectValue = method.invoke (poCordHighlightDetails);
									
									if(poCordHighlightDetails.getUploadId()!=null)
									{
										uploadId = poCordHighlightDetails.getUploadId();
									}
									

									if(uploadId!=null)
									{
										if(oldUploadId!=null)
										{
											if(uploadId.intValue()!=oldUploadId.intValue())
											{
												fileType=getProcessedFilesFileTypeByFilingIdAndUploadId(fillingId,uploadId);
											}
										}
										else
										{
											if(fileType==null || fileType.length()==0)
											fileType=getProcessedFilesFileTypeByFilingId(fillingId);
										}
					
										oldUploadId=uploadId;
									}
									else
									{
										if(fileType==null || fileType.length()==0)
										fileType=getProcessedFilesFileTypeByFilingId(fillingId);
									}
									
									if(objectValue!=null && objectValue.toString().length()>0 && objectValue.toString()!="0.0,0.0,0.0,0.0,1")
									{
										selectedNormalizedDetails.setClickbackExists("Y");
										selectedNormalizedDetails.setPoId(poId);
										selectedNormalizedDetails.setCoordinateColumn(coordinateColumn);
										selectedNormalizedDetails.setCoordinates(fileType+"|"+objectValue.toString());
										if(poIdArsLabelMap!=null && poIdArsLabelMap.get(poId)!=null)
										{
											selectedNormalizedDetails.setUploadId(poIdArsLabelMap.get(poId).getUploadId());
										}
										else
										{
											selectedNormalizedDetails.setUploadId(0);
										}
										
									}
									else
									{
										selectedNormalizedDetails.setClickbackExists("N");
									}
								}
								else
								{
									selectedNormalizedDetails.setClickbackExists("N");
								}
								if(poIdArsLabelMap!=null && !poIdArsLabelMap.isEmpty() && poIdArsLabelMap.containsKey(poId))
								{
									asRepLabel = poIdArsLabelMap.get(poId).getPoAsRepLabel();
									if(asRepLabel!=null && !asRepLabel.isEmpty())
									selectedNormalizedDetails.setAsRepLabel(asRepLabel);
								}
								listOfNormalisedDetails.add(selectedNormalizedDetails);
							}
					} catch (NumberFormatException e) {
						e.printStackTrace();
					} catch (NoSuchMethodException e) {
						e.printStackTrace();
					} catch (SecurityException e) {
						e.printStackTrace();
					} catch (IllegalAccessException e) {
						e.printStackTrace();
					} catch (IllegalArgumentException e) {
						e.printStackTrace();
					} catch (InvocationTargetException e) {
						e.printStackTrace();
					}
				}
		
			Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("templateId", templateId);
			
			List<Object> sectionOrder  = null;
			sectionOrder  = genericDaoImpl.findByNamedQuery(NamedQueryName.getSectionOrderForTemplate, TemplateSectionOrder.class,parameterMap);
			
			if(sectionOrder== null || sectionOrder.isEmpty())
			{
				parameterMap.put("templateId", -1);	
				sectionOrder  = genericDaoImpl.findByNamedQuery(NamedQueryName.getSectionOrderForTemplate, TemplateSectionOrder.class,parameterMap);
			}
			
			List<String> sortOrder = new ArrayList<String>();
			for (Object object : sectionOrder) 
			{
				sortOrder.add(object.toString());
			}

			//sort the list according to sortOrder
			Collections.sort(listOfNormalisedDetails,new NormalizedDetailsByDisplaySequenceComparator());
			Collections.sort(listOfNormalisedDetails, new NormalizedDetailsComparator(sortOrder));
			List<String> listOfFinalSections = new ArrayList<String>(listOfSections);
			Collections.sort(listOfFinalSections, new NormalzedLabelsDetailsComparator(sortOrder));
			//Map of NormalizedDetails with Key as niItemId
			//User for separate the val data wrt niItemId
			
			Map<Integer, List<NormalizedDetails>> normIdMap = null; 		
			if(!CollectionUtils.isEmpty(listOfNormalisedDetails))
			{	
				normIdMap = new LinkedHashMap<Integer, List<NormalizedDetails>>();
				List<NormalizedDetails> details = null;
				for ( NormalizedDetails  selectedNormDetails: listOfNormalisedDetails) 
				{
					if(normIdMap.containsKey(selectedNormDetails.getNiItem()))
					{
						normIdMap.get(selectedNormDetails.getNiItem()).add(selectedNormDetails);
					}
					else 
					{
						details = new ArrayList<NormalizedDetails>();
						details.add(selectedNormDetails);
						normIdMap.put(selectedNormDetails.getNiItem(), details);
					}
				}
			}
			
			List<NormalisedLabelAndValues> listOfNormalisedLabelAndValues = null;
			Map<String, List<NormalisedLabelAndValues>> finalOrderedMap = null;	
			/**
			 * Here we sort NormalizedDetails list based on client or LS data.
			 */
			List<String> sourceDataSortingList=new ArrayList<>();
			sourceDataSortingList.add("LS");
			sourceDataSortingList.add("Client");
			
			if(!CollectionUtils.isEmpty(normIdMap))
				{
					finalOrderedMap = new LinkedHashMap<String, List<NormalisedLabelAndValues>>();
					NormalisedLabelAndValues labelAndValues = null;
					for (Map.Entry<Integer, List<NormalizedDetails>> selectedNormDetails :normIdMap.entrySet()) 
					{
						// Creating the NormalisedLabelAndValues list using normIdMap
						if(selectedNormDetails.getValue().get(0)!=null)
						{
							labelAndValues = new NormalisedLabelAndValues();
							labelAndValues.setDisplayFormat(selectedNormDetails.getValue().get(0).getDisplayFormat());
							labelAndValues.setHeader(selectedNormDetails.getValue().get(0).getHeader());
							labelAndValues.setLabel(selectedNormDetails.getValue().get(0).getLabel());
							labelAndValues.setNi_item(selectedNormDetails.getValue().get(0).getNiItem());
							
							labelAndValues.setIsRefPoId(selectedNormDetails.getValue().get(0).getIsRefPoId());
							labelAndValues.setIsMultiRefPoId(selectedNormDetails.getValue().get(0).getIsMultiRefPoId());
							labelAndValues.setNivId(selectedNormDetails.getValue().get(0).getNivId());
							labelAndValues.setClickbackExists(selectedNormDetails.getValue().get(0).getClickbackExists());
							labelAndValues.setPoId(selectedNormDetails.getValue().get(0).getPoId());
							labelAndValues.setCoordinateColumn(selectedNormDetails.getValue().get(0).getCoordinateColumn());
							labelAndValues.setAccountId(selectedNormDetails.getValue().get(0).getAccountId());
							labelAndValues.setAccountDisplayLongDs(selectedNormDetails.getValue().get(0).getAccountDisplayLongDs());
							labelAndValues.setLabelHierarchy(selectedNormDetails.getValue().get(0).getLabelHierarchy());
							labelAndValues.setCoordinates(selectedNormDetails.getValue().get(0).getCoordinates());
							
							if(poIdArsLabelMap!=null && poIdArsLabelMap.get(labelAndValues.getPoId())!=null)
							{
								labelAndValues.setUploadId(poIdArsLabelMap.get(labelAndValues.getPoId()).getUploadId());
							}
							else
							{
								labelAndValues.setUploadId(0);
							}
							//start codetest
							labelAndValues.setAsRepLabel(selectedNormDetails.getValue().get(0).getAsRepLabel());
							labelAndValues.setIsValueMatch(selectedNormDetails.getValue().get(0).getIsValueMatch());
							labelAndValues.setPeriod(selectedNormDetails.getValue().get(0).getArs_period());
							labelAndValues.setTemplateId(templateId);
							labelAndValues.setCategory(selectedNormDetails.getValue().get(0).getCategory());
							
							//End codetest
							
							/*clickback code end */
							
							List<NormalizedDetails> tmpList = null;
							//order the List of NormalizedDetails wrt ARS date and period for IS and ARS date for other sections
							if(selectedNormDetails.getValue()!=null && !selectedNormDetails.getValue().isEmpty())
							{
								tmpList = new ArrayList<NormalizedDetails>();
								boolean status = false;
								for(int count=0; count<str_Headerlist.size(); count++)
								{
									status = false;
									for ( NormalizedDetails details : selectedNormDetails.getValue()) 
									{
											if( !CollectionUtils.isEmpty(arsIdList) && details.getArsDate()!=null && details.getArsId()!=null && arsIdList.get(count).equals(details.getArsId().toString()) )
											{
												tmpList.add(details);	
												details.setIsUsed("Y");
												status = true;
												//break;
											}
										}
										if(!status)
										{
											tmpList.add(null);
										}
									}

								//Here check tmpList contain any list element.
								 boolean listNullElementFlag=true;
								    for (Object element : tmpList)
								    {
								    if (element == null){
								    	listNullElementFlag=false;
								    	break;
								    }
								   }
								    
								if(listNullElementFlag)
								Collections.sort(tmpList, new NormalizedDetailsComparatorForSourceData(sourceDataSortingList));
								/**End Source Data Sorting **/
								
								labelAndValues.setList(tmpList);
								}
								if(finalOrderedMap.containsKey(selectedNormDetails.getValue().get(0).getSection()))
								{
									finalOrderedMap.get(selectedNormDetails.getValue().get(0).getSection()).add(labelAndValues);
								}
								else 
								{
									listOfNormalisedLabelAndValues = new ArrayList<NormalisedLabelAndValues>();
									listOfNormalisedLabelAndValues.add(labelAndValues);
									finalOrderedMap.put(selectedNormDetails.getValue().get(0).getSection(), listOfNormalisedLabelAndValues);
								}
							}
						}
					}
			return finalOrderedMap;	
		}




	@SuppressWarnings("unused")
	private boolean checkIfDataIsPresent(
			List<NormalisedLabelAndValues> listOfNormalisedLabelAndValues,
			Integer ni_item) {
		for (NormalisedLabelAndValues normalisedLabelAndValues : listOfNormalisedLabelAndValues) {

			if (normalisedLabelAndValues.getNi_item().intValue() == ni_item
					.intValue()) {
				return false;
			}
		}
		return true;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getListOfSection(String section,Integer templateId) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("section", section);
		parameterMap.put("templateId", templateId);
		LOGGER.info(" **start- getListOfSubSection method ");
		List<String> subSectionList = (ArrayList<String>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getSubSectionListByTemplateId,NormItemLabels.class, parameterMap);
		subSectionList.add("ATTR");
		subSectionList.add("HEADER");
		Collections.sort(subSectionList);
		LOGGER.info(" **end- getListOfSubSection method ");
		return subSectionList;
	}
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void updateFilings(Integer fillingId, String type, Integer templateId) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("templateIndustry", type);
		parameterMap.put("templateId", templateId);
		LOGGER.info(" **start- updateFilings method ");
		Filings filings = new Filings();
		filings.setTemplateId(templateId);
		filings.setFiling_id(fillingId);
		filings.setTemplateIndustry(type);
		genericDaoImpl.updateByNamedQuery(
				NamedQueryName.updateFilingsByFillingId, Filings.class,
				parameterMap);
		LOGGER.info(" **end- updateFilings method ");
	}

	@Override
	public Integer saveToRequestQueueForNormalizeTemplate(Integer fillingId,String type,String processName) {
			String parameters = "<Parameters>"
					+ "<Parameter><Name>Filing_ID</Name><Value>"+fillingId+"</Value></Parameter>"
					+ "<Parameter><Name>Process_cat</Name><Value>MODIFY STATUS-MAPPING SUCCESS</Value></Parameter>"
					+ "</Parameters>";
			
			Integer requestId =rageProcessRequestQueue(processName,parameters);
			return requestId;
	}

	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public String insertGlobelLevelData(NormalizeFormData nfd) {
		int updateCount=0;
		int insertCount=0;
		int exactCount = 0;
		StringBuffer poids=new StringBuffer();
		Integer fillingId = nfd.getFillingId();
		Integer templateId = nfd.getTemplateId();
		List<String> poIdStringList = nfd.getNormDictPoId();
		Map<String, Object> parameterMap = null;
		Map<String, Object> parameterMapUpdate = null;
		Integer fiId=0;
		FinancialItems financialItems =null;
		parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", fillingId);
		Filings filingObj = genericDaoImpl.findByColumn(NamedQueryName.getTemplateId, Filings.class, parameterMap);
		String industry = filingObj.getTemplateIndustry();
		//String language = "English"; // filingObj.getTemplateLanguage();
		String language = workQueueService.findLanguageByFilingId(fillingId);
		/**
		* 1:Here if search type( Normalized Directory) is Company Level then we require e_id based on filingid
		* 2:IF Indsutry level then need to update Indusrty_id in financial_item table
		*/
		Integer eId=0;
		Integer industryId=0;
		User userObject = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		WorkQueue workQueue = workQueueService.getWorkQueueDetailsUsingFilingId(fillingId);
		if(nfd.getSearchype().equalsIgnoreCase("CompanyLevel")){
			industryId=0;
			if(filingObj.getE_id()!=null)
			 eId=filingObj.getE_id();
		}else if(nfd.getSearchype().equalsIgnoreCase("IndustryLevel"))
		{
			try
			{
		    eId=0;	
			industryId=workQueue.getIndustryType();
			}catch(NumberFormatException nfe)
			{
		 	LOGGER.error(nfe.getMessage());
			}
		}
		else
		{
			industryId=0;
		}
		
		List<Integer> rowLevelMappingList = null;
		List<String> cellLevelMappingList = null;
		if(poIdStringList!=null & !poIdStringList.isEmpty())
		{
			rowLevelMappingList = new ArrayList<>();
			cellLevelMappingList = new ArrayList<>();
			for (String poIdString : poIdStringList) 
			{
				String[] poIdDetails =  poIdString.split("~");
				if(poIdDetails[1].toString().equalsIgnoreCase("rowLevel"))
				{
					rowLevelMappingList.add(Integer.parseInt(poIdDetails[0]));
				}
				else
				{
					cellLevelMappingList.add(poIdString);
				}
			}
		}
		
		
		if(!CollectionUtils.isEmpty(rowLevelMappingList))
		{
			parameterMap = new HashMap<String, Object>();
			parameterMap.put("fillingId", fillingId);
			parameterMap.put("poIdList", rowLevelMappingList);
			List<ParserOutput> parserOutputList = (ArrayList<ParserOutput>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getDataForGlobelLevel, ParserOutput.class,parameterMap);
			LOGGER.info("getDataForGlobelLevel completed with result size"+ parserOutputList.size());
			if (!CollectionUtils.isEmpty(parserOutputList)) 
			{
				fiId=0;
				FinancialItems selectedFinanciaItem=null;;
				String mappingName="";
				String mappingArray[]=null;
				boolean isAlreadyExist = false;
				for (ParserOutput poutput : parserOutputList) {
					isAlreadyExist = false;
					selectedFinanciaItem=checkExistRecords(poutput.getPoAsRepLabel(),poutput.getPoSubSection(),poutput.getNilLabel(),nfd.getSearchype(),poutput.getPoSection(),poutput.getNiItem(),eId,templateId,null,null,industryId);
					if(selectedFinanciaItem!=null)
					{
							fiId = selectedFinanciaItem.getFiId();
							parameterMapUpdate = new HashMap<String, Object>();
							if(selectedFinanciaItem.getMatchType().equalsIgnoreCase("Relative"))
							{
								parameterMapUpdate.put("fiId", fiId);
								parameterMapUpdate.put("niItem", poutput.getNiItem());
								genericDaoImpl.updateByNamedQuery(NamedQueryName.updateFinancialItemsRecordbyFiId, FinancialItems.class, parameterMapUpdate);
								updateCount++;
								if (poids.toString().isEmpty()) {
									poids.append(poutput.getPoId());
								}else {
									poids.append("$"+poutput.getPoId());
								}
							}else
							{
								isAlreadyExist=true;
								exactCount++;
							}
						
					}else{	
						financialItems= new FinancialItems();
						financialItems.setFiLabel(poutput.getPoAsRepLabel().trim());
						financialItems.setFiSection(poutput.getPoSection().trim());
						financialItems.setFiSubSection(poutput.getPoSubSection().trim());
						financialItems.setNiItem(poutput.getNiItem());
						financialItems.setFiIndexOrder(poutput.getPoIndexOrder());
						financialItems.setTemplateId(templateId);
						if(nfd.getSearchype().equalsIgnoreCase("IndustryLevel")){
							financialItems.setIndustryId(industryId);
						}else{
							financialItems.setIndustryId(0);
						}
						financialItems.setFiIndustry(industry);
						financialItems.setFiLanguage(language);
						financialItems.setCreatedDate(new Date());
						financialItems.setAnalystId((int) (long) userObject.getUserId());
						financialItems.setCreatedBy(userObject.getUsername());
						financialItems.setFiSearchType(nfd.getSearchype());
						financialItems.seteId(eId);
						if(workQueue.getWqParserDescription()!=null && workQueue.getWqParserDescription().equalsIgnoreCase("PDF Based ITR"))
						{
							financialItems.setIsParserSpecific("Y");
							financialItems.setParserDescription("PDF Based ITR");
						}
						financialItems.setFiStatus("Pending");
						genericDaoImpl.persist(financialItems);
						insertCount++;
						if (poids.toString().isEmpty()) {
							poids.append(poutput.getPoId());
						}else {
							poids.append("$"+poutput.getPoId());
						}
				    } 
					
					/**
					 * below code used for bulk update MAPPING_NAME column in parser_output table based on po_id	
					 */
					if (!CollectionUtils.isEmpty(parserOutputList) && !isAlreadyExist){
					  mappingName=poutput.getMappingName();
					    if(mappingName!=null && !mappingName.isEmpty() && !mappingName.equalsIgnoreCase(nfd.getSearchype())){
					    	mappingArray=mappingName.split(",");
					    	if(mappingArray==null || mappingArray.length<=2){
					    		mappingName=mappingName+","+nfd.getSearchype(); 
					    	}
					    }else{
					    	mappingName=nfd.getSearchype();
					    }
						 Map<String,Object> parameters=new HashMap<String,Object>();
						 parameters.put("mappingName", mappingName);
						 parameters.put("poIdList", poutput.getPoId());
						 genericDaoImpl.updateByNamedQuery(NamedQueryName.updateMappingNameByPoId, ParserOutput.class,parameters);
			     	 }
				}
			}
		}
		
		if(!CollectionUtils.isEmpty(cellLevelMappingList))
		{

			List<ArsPoCommand> arsPoCommandList =  new ArrayList<>();
			ArsPoCommand arsPoCommand = null;
			FinancialItems selectedFinanciaItem=null;
			for (int count = 0;count<cellLevelMappingList.size();count++)
			{
				String cellPoIdDetails = cellLevelMappingList.get(count);
				String[] cellDetails = cellPoIdDetails.split("~");
				try {
					arsPoCommand =  normalizationViewDAO.f_fetchArsPoMappingBYPoIdAndColName(Integer.parseInt(cellDetails[0].toString()),cellDetails[2].toString());
				} catch (Exception e) {
					LOGGER.error("Object Not Exists");
				}
				if(arsPoCommand!=null)
				{
					arsPoCommandList.add(arsPoCommand);
				}
			}
			
			if (!CollectionUtils.isEmpty(arsPoCommandList)) {
				for (ArsPoCommand command : arsPoCommandList) {
					selectedFinanciaItem=checkExistRecords(command.getPoAsRepLabel(),command.getPoSubSection(),command.getNilLabel(),nfd.getSearchype(),command.getPoSection(),command.getNiItem(),eId,templateId,command.getHeaderLabel(),command.getTabelLabel(),industryId);
					if(selectedFinanciaItem!=null)
					{
						fiId = selectedFinanciaItem.getFiId();
							if(selectedFinanciaItem.getMatchType().equalsIgnoreCase("Relative"))
							{
								parameterMapUpdate = new HashMap<String, Object>();
								parameterMapUpdate.put("fiId", fiId);
								parameterMapUpdate.put("niItem", command.getNiItem());
								genericDaoImpl.updateByNamedQuery(NamedQueryName.updateFinancialItemsRecordbyFiId, FinancialItems.class, parameterMapUpdate);
								updateCount++;
								if (poids.toString().isEmpty()) {
									poids.append(command.getPoId());
								}else {
									poids.append("$"+command.getPoId());
								}
							}else
							{
								exactCount++;
							}
					}else{
						financialItems = new FinancialItems();
						financialItems.setFiLabel(command.getPoAsRepLabel());
						financialItems.setFiSection(command.getPoSection());
						financialItems.setFiSubSection(command.getPoSubSection());
						financialItems.setNiItem(command.getNiItem());
						financialItems.setFiIndexOrder(command.getPoIndexOrder());
						financialItems.setTemplateId(templateId);
						financialItems.setFiIndustry(industry);
						financialItems.setFiLanguage(language);
						financialItems.setCreatedDate(new Date());
						financialItems.setAnalystId((int) (long) userObject.getUserId());
						financialItems.setCreatedBy(userObject.getUsername());
						financialItems.setFiSearchType(nfd.getSearchype());
						financialItems.seteId(eId);
						financialItems.setHeaderLabel(command.getHeaderLabel());
						financialItems.setTableLabel(command.getTabelLabel());
						if(nfd.getSearchype().equalsIgnoreCase("IndustryLevel")){
							financialItems.setIndustryId(industryId);
						} else{
							financialItems.setIndustryId(0);
						}
						
						if(workQueue.getWqParserDescription()!=null && workQueue.getWqParserDescription().equalsIgnoreCase("PDF Based ITR"))
						{
							financialItems.setIsParserSpecific("Y");
							financialItems.setParserDescription("PDF Based ITR");
						}
						financialItems.setFiStatus("Pending");
						genericDaoImpl.persist(financialItems);
						insertCount++;
						if (poids.toString().isEmpty()) {
							poids.append(command.getPoId());
						}else {
							poids.append("$"+command.getPoId());
						}
						parameterMap=new HashMap<String,Object>();
					    String mappingName=command.getMappingName();
					    if(mappingName!=null && !mappingName.isEmpty() && !mappingName.equalsIgnoreCase(nfd.getSearchype())){
					    	mappingName=mappingName+","+nfd.getSearchype(); 
					    }else{
					    	mappingName=nfd.getSearchype();
					    }
						parameterMap.put("mappingName", mappingName);
						parameterMap.put("poId", command.getPoId());
						parameterMap.put("poColumnName", command.getColName());
						try {
							genericDaoImpl.updateByNamedQuery(NamedQueryName.updateMappingNameByPoIdandColName, ArsPoMapping.class,parameterMap);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					}
			}
		}
/*		result=updateCount+insertCount;
		if(result==1000){
			return result+"#"+result+"#"+exactCount+"#"+poids.toString();
		}
		if(result==0 && poids.toString().isEmpty()){
			return "";	 
		}*/
		return updateCount+"#"+insertCount+"#"+exactCount+"#"+poids.toString();

	}
	
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	private FinancialItems checkExistRecords(String poAsLabel,String subSection,String NilLabel, String searchType,String section,Integer niItem,Integer eId,Integer templateId, String headerLabel, String tabelLabel, Integer industryId){
		
		 List<Object[]> idList=null;
		StringBuffer query=new StringBuffer();
		FinancialItems selectedFinancialItems = null;
		Map<String, Object> parameter = new HashMap<String, Object>();
		String condition ="";
		if (poAsLabel != null && !poAsLabel.isEmpty()) {
			query.append("upper(RTRIM(LTRIM(FI_LABEL)))=upper(:poAsRepLabel) ");
			parameter.put("poAsRepLabel", poAsLabel.trim());
			condition=" and ";
		} 
		if (subSection != null && !subSection.isEmpty()) {
			query.append(condition).append("upper(RTRIM(LTRIM(FI_SUB_SECTION)))=upper(:subSection) ");
			parameter.put("subSection", subSection.trim());
			condition=" and ";
		} 
		if (section != null && !section.isEmpty()) {
			query.append(condition).append("RTRIM(LTRIM(FI_SECTION))=:section ");
			parameter.put("section", section.trim());
			condition=" and ";
		} 
		if (eId != null) {
			query.append(condition).append("E_ID=:eId  ");
			parameter.put("eId", eId);	
			condition=" and ";
		} 
		
		if (searchType != null) {
			
			if (templateId != null) {
				query.append(condition).append("TEMPLET_ID=:templateId ");
				parameter.put("templateId", templateId);	
				condition=" and ";
			} 
			query.append(condition).append("upper(RTRIM(LTRIM(FI_SEARCHTYPE)))=upper(:searchType) ");
			parameter.put("searchType", searchType.trim());
			condition=" and ";
		} 
		
		if (headerLabel != null && !headerLabel.isEmpty()) {
			query.append(condition).append("upper(RTRIM(LTRIM(HEADER_LABEL)))=upper(:headerLabel) ");
			parameter.put("headerLabel", headerLabel.trim());	
			condition=" and ";
		} 
		
		if (tabelLabel != null && !tabelLabel.isEmpty()) {
			query.append(condition).append("upper(RTRIM(LTRIM(TABLE_LABEL)))=upper(:tabelLabel) ");
			parameter.put("tabelLabel", tabelLabel.trim());
			condition=" and ";
		} 
		if (searchType!=null && searchType.equalsIgnoreCase("IndustryLevel") && industryId != null) {
			query.append(condition).append("INDUSTRY_ID = :industryId ");
			parameter.put("industryId", industryId);
			condition=" and ";
		} 
			
		try{
			if(query!=null){
				   String dyQuery=" select FI_ID,NI_ITEM,FI_STATUS from FINANCIAL_ITEMS  where "+query;
		            idList =  genericDaoImpl.findBySql(dyQuery, parameter);
				}
			if(!CollectionUtils.isEmpty(idList)){
				
				if(idList.size()>1)
				{
					int count =0;
					List<Integer> financialItemsIdLIst = new ArrayList<Integer>();
					for (Object[] selectedObject : idList) 
					{
						if(count>0)
						{
							financialItemsIdLIst.add(new Integer(selectedObject[0].toString()));
						}
						count++;
					}
					Map<String, Object> parameterMap = new HashMap<String, Object>();
					parameterMap.put("FI_ID_LIST", financialItemsIdLIst);
					genericDaoImpl.removeByNamedQuery(NamedQueryName.deleteFinancialItems,FinancialItems.class,parameterMap);
				}
				selectedFinancialItems = new FinancialItems();
				
				selectedFinancialItems.setFiId(Integer.parseInt(idList.get(0)[0].toString()));
				selectedFinancialItems.setFiStatus(idList.get(0)[2].toString());
				Integer selectedNiItem = Integer.parseInt(idList.get(0)[1].toString());
				if(selectedNiItem.equals(niItem))
				{
					selectedFinancialItems.setMatchType("Exact");
				}
				else
				{
					selectedFinancialItems.setMatchType("Relative");
				}
			}

		}catch(Exception e){
			e.printStackTrace();
		}
		
		return selectedFinancialItems;
	}

	@SuppressWarnings("unused")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void importExcelDataInParserOutPut(List<ParserOutput> pOutPutList,
			Integer customerId, Integer fillingId) {
		try{
		if (null != pOutPutList && pOutPutList.size() > 0)
		{
			int result = 0;
			Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("fillingId", fillingId);
			/**
			 * Here we are deleting parser_output records by filing id
			 */
			int deleteFlag = genericDaoImpl.updateByNamedQuery(NamedQueryName.deleteParserOutputRecordsByFilingId, ParserOutput.class,parameterMap);
			ExcelImportJDBCBatchUpdate.batchInsertRecordsIntoTable(pOutPutList);
			
		}
		}catch (Exception e) {
		e.printStackTrace();
		}
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<String> getAccountNoFromParserOutput(Integer fillingId,
			String po_Section) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("po_Section", po_Section);
		LOGGER.info(" **start- getAccountNoFromParserOutput method ");
		List<String> accountNumbers = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctAccountNo,
						ParserOutput.class, parameterMap);
		LOGGER.info(" **end- getAccountNoFromParserOutput method ");
		return accountNumbers;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getTimePeriodFromParserOutput(Integer fillingId,
			String po_Section) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("po_Section", po_Section);
		LOGGER.info(" **start- getTimePeriodFromParserOutput method ");
		List<String> timePeriod = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctTimePeriod,
						ParserOutput.class, parameterMap);
		LOGGER.info(" **end- getTimePeriodFromParserOutput method ");
		return timePeriod;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getcustodianNameFromParserOutput(Integer fillingId,
			String po_Section) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("po_Section", po_Section);
		LOGGER.info(" **start- getcustodianNameFromParserOutput method ");
		List<String> custodianName = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctCustodianName,
						ParserOutput.class, parameterMap);
		LOGGER.info(" **end- getcustodianNameFromParserOutput method ");
		return custodianName;
	}

	@Override
	public List<ParserOutput> getNormalizedDataByFilter(String stmtFormat, int WqId, int fillingid,Integer startNum,Integer endNum,String accountNumber,String timePeriod,String custodianName,String updatedAllPoId) {
		LOGGER.info("getNormalizedDataByFilter started");
		LOGGER.debug("getNormalizedDataByFilter started with" + stmtFormat + WqId);
		List<ParserOutput> parserOutput = null;
		try {
			parserOutput = normalizationViewDAO.getNormalizedSearchDataForBankParser(fillingid, stmtFormat, startNum, endNum,accountNumber,timePeriod,custodianName,updatedAllPoId);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return parserOutput;
	}



	@SuppressWarnings("unchecked")
	@Override
	public List<String> f_getTimePeriodByAccountNumber(Integer fillingId,
			String po_Section, String accountNumber) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("po_Section", po_Section);
		parameterMap.put("accountNumber", accountNumber);
		LOGGER.info(" **start- getcustodianNameFromParserOutput method ");
		List<String> timePeriodList = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctTimePeriodByAccountNumber,
						ParserOutput.class, parameterMap);
		List<String> timePeriodList1 = new ArrayList<String>();
		for (String time : timePeriodList) {
			timePeriodList1.add("<option>" + time + "</option>");
		}
		LOGGER.info(" **end- getcustodianNameFromParserOutput method ");
		return timePeriodList1;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> f_getCustodianNameByAccountNumber(Integer fillingId,
			String po_Section, String accountNumber) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("po_Section", po_Section);
		parameterMap.put("accountNumber", accountNumber);
		LOGGER.info(" **start- getcustodianNameFromParserOutput method ");
		List<String> custodianNameList = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctCustodianNameByAccountNumber,
						ParserOutput.class, parameterMap);
		List<String> custodianNameList1 = new ArrayList<String>();
		for (String custodianName : custodianNameList) {
			custodianNameList1.add("<option>" + custodianName + "</option>");
		}
		LOGGER.info(" **end- getcustodianNameFromParserOutput method ");
		return custodianNameList1;
	}

	@SuppressWarnings("unused")
	@Override
	public Map<String, Map<String, Object>> getBankHeaderDetails(
			List<String> accList, Integer fillingId) {
		LOGGER.info("-------------- getHeaderDetails started -------------------");
		DateFormat formatter = new SimpleDateFormat("MMM-yyyy");
		Map<String, Map<String, Object>> returnMap = new HashMap<String, Map<String, Object>>();
		/*
		 * Here we get template id from filings table based on filing_id
		 */
		Map<String, Object> parameterMapOne = new HashMap<String, Object>();
		parameterMapOne.put("filingId", fillingId);
		LOGGER.info("-------------- getListOfNormItemLabels started -------------------");
		Filings templateId = genericDaoImpl.findByColumn(
				NamedQueryName.getTemplateId, Filings.class, parameterMapOne);
		Map<String, Object> parameterMapNormItem = new HashMap<String, Object>();
		parameterMapNormItem.put("template_id", templateId.getTemplateId());
		if ((accList != null) && (accList.size() > 0)) {
			for (String account : accList) {
				HashMap<String, Object> internalMap = new HashMap<String, Object>();
				String showNIItemValueMapFlag = "true";
				String showNIDepositItemValueMap = "true";
				List<Object> listNIBankAccountSummaryHeaders = genericDaoImpl
						.findByNativeNamedQuery(
								NamedNativeQueryName.getBankAccountSummaryHeaders,
								NormItemLabels.class, parameterMapNormItem);
				List<Object> listNIBankDepositsHeaders = genericDaoImpl
						.findByNativeNamedQuery(
								NamedNativeQueryName.getBankDepositsHeaders,
								NormItemLabels.class, parameterMapNormItem);
				HashMap<String, Object> parameters = new HashMap<String, Object>();
				parameters.put("accountNumer", account);
				parameters.put("filingId", fillingId);
				List<Object> listNIBankValues = genericDaoImpl
						.findByNativeNamedQuery(
								NamedNativeQueryName.getBankHeadersByAccountID,
								NIBankValues.class, parameters);
				Map<String, List<Integer>> mapOfNiItem = new LinkedHashMap<String, List<Integer>>();
				Map<Integer, List<NormalizedDetails>> mapOfValueDetails = new LinkedHashMap<Integer, List<NormalizedDetails>>();
				Map<Integer, List<NormalizedDetails>> mapOfDepositValueDetails = new LinkedHashMap<Integer, List<NormalizedDetails>>();
				Set<Integer> niItemList = new LinkedHashSet<Integer>();
				Set<Integer> niItemDepositList = new LinkedHashSet<Integer>();
				Set<String> niItemHeaderList = new LinkedHashSet<String>();
				for (Object object : listNIBankAccountSummaryHeaders) {
					Object[] objIn = (Object[]) object;
					Integer NiItem = objIn[2] == null ? 0 : Integer
							.parseInt(objIn[2].toString());
					niItemList.add(NiItem);
					if (niItemList.size() > 0)
						niItemList.add(new Integer("100000")); // assume the
																// 100000 is the
																// NiItem for
																// "Calculated Balance"
				}
				for (Object object : listNIBankDepositsHeaders) {
					Object[] objIn = (Object[]) object;
					Integer NiItem = objIn[2] == null ? 0 : Integer
							.parseInt(objIn[2].toString());
					niItemDepositList.add(NiItem);
				}
				for (Object object : listNIBankValues) {
					Object[] objIn = (Object[]) object;
					Date stamentdt = objIn[7] == null ? null : (Date) objIn[7];
					if (stamentdt != null) {
						String str_stamentdt = formatter.format(stamentdt);
						if (str_stamentdt != null)
							niItemHeaderList.add(getLongMonth(str_stamentdt));
					}
				}
				List<Integer> niItemFinalList = new ArrayList<Integer>(
						niItemList);
				List<Integer> niItemFinalDepositList = new ArrayList<Integer>(
						niItemDepositList);
				List<String> strNIItemHeaderList = new ArrayList<String>(
						niItemHeaderList);
				Collections.sort(niItemFinalList);
				Collections.sort(niItemFinalDepositList);
				mapOfNiItem.put("NIItemList", niItemFinalList);
				mapOfNiItem.put("NIItemDepositList", niItemFinalDepositList);
				internalMap.put("NIItemMap", mapOfNiItem);
				if (niItemFinalList.size() > 0
						&& strNIItemHeaderList.size() > 0) {
					for (Integer niItem : niItemFinalList) {
						List<NormalizedDetails> normalizedDetails = new ArrayList<NormalizedDetails>();
						for (String niItemHeader : strNIItemHeaderList) {
							NormalizedDetails NDV = new NormalizedDetails();
							NDV.setDate(niItemHeader);
							NDV.setNiItem(niItem);
							if (niItem == 100000)
								NDV.setValue("0");
							normalizedDetails.add(NDV);
						}
						mapOfValueDetails.put(niItem, normalizedDetails);
					}
				}
				if (niItemFinalDepositList.size() > 0
						&& strNIItemHeaderList.size() > 0) {
					for (Integer niItem : niItemFinalDepositList) {
						List<NormalizedDetails> normalizedDetails = new ArrayList<NormalizedDetails>();
						for (String niItemHeader : strNIItemHeaderList) {
							NormalizedDetails NDV = new NormalizedDetails();
							NDV.setDate(niItemHeader);
							NDV.setNiItem(niItem);
							normalizedDetails.add(NDV);
						}
						mapOfDepositValueDetails.put(niItem, normalizedDetails);
					}
				}
				for (Object object : listNIBankValues) {
					double currentCalculatedBalanceVal = 0d;
					Object[] objIn = (Object[]) object;
					Integer currentNiItem = objIn[3] == null ? 0 : Integer
							.parseInt(objIn[3].toString());
					if ((currentNiItem == 480) || (currentNiItem == 490)
							|| (currentNiItem == 500)
							|| (currentNiItem == 2940)) {
						List<NormalizedDetails> NormalizedDetailsList = mapOfDepositValueDetails
								.get(currentNiItem);
						String NiItemVal = objIn[4] == null ? "" : objIn[4]
								.toString();
						Date stamentdt = objIn[7] == null ? null
								: (Date) objIn[7];
						if (stamentdt != null) {
							String str_stamentdt = formatter.format(stamentdt);
							NormalizedDetailsList
									.get(strNIItemHeaderList
											.indexOf(getLongMonth(str_stamentdt)))
									.setValue(NiItemVal);
						}
					} else {
						List<NormalizedDetails> calculatedBalanceNormalizedDetailsList = mapOfValueDetails
								.get(new Integer("100000"));
						String NiItemVal = objIn[4] == null ? "" : objIn[4]
								.toString();
						Date stamentdt = objIn[7] == null ? null
								: (Date) objIn[7];
						if (stamentdt != null) {
							String str_stamentdt = formatter.format(stamentdt);
							if ((currentNiItem == 130)
									|| (currentNiItem == 140)
									|| (currentNiItem == 150)
									|| (currentNiItem == 160)) {
								List<NormalizedDetails> NormalizedDetailsList = mapOfValueDetails
										.get(currentNiItem);
								if (stamentdt != null) {
									String str_stamentdt1 = formatter
											.format(stamentdt);
									NormalizedDetailsList
											.get(strNIItemHeaderList
													.indexOf(getLongMonth(str_stamentdt1)))
											.setValue(NiItemVal);
								}
							}
							if (calculatedBalanceNormalizedDetailsList
									.get(strNIItemHeaderList
											.indexOf(getLongMonth(str_stamentdt)))
									.getValue() != null)
								currentCalculatedBalanceVal = Double
										.parseDouble(calculatedBalanceNormalizedDetailsList
												.get(strNIItemHeaderList
														.indexOf(getLongMonth(str_stamentdt)))
												.getValue());
							// replaceAll(regex, replacement)
							if (currentNiItem == 130) {
								String currentCalculatedBalanceVal1 = "";
								if ((NiItemVal != null) && (NiItemVal != ""))
									currentCalculatedBalanceVal1 = roundAddDecimal(
											currentCalculatedBalanceVal,
											Double.parseDouble(NiItemVal));
								else {
									currentCalculatedBalanceVal1 = "0";
								}
								calculatedBalanceNormalizedDetailsList
										.get(strNIItemHeaderList
												.indexOf(getLongMonth(str_stamentdt)))
										.setValue(
												currentCalculatedBalanceVal1
														+ "");
							} else if (currentNiItem == 140) {								
								String currentCalculatedBalanceVal1 = "";
								if ((NiItemVal != null) && (NiItemVal != ""))
									currentCalculatedBalanceVal1 = roundAddDecimal(
											currentCalculatedBalanceVal,
											Double.parseDouble(NiItemVal));
								else {
									currentCalculatedBalanceVal1 = "0";
								}
								calculatedBalanceNormalizedDetailsList
										.get(strNIItemHeaderList
												.indexOf(getLongMonth(str_stamentdt)))
										.setValue(currentCalculatedBalanceVal1);
							} else if (currentNiItem == 150) {
								String currentCalculatedBalanceVal1 = "";
								if ((NiItemVal != null) && (NiItemVal != ""))
									currentCalculatedBalanceVal1 = roundSubtractDecimal(
											currentCalculatedBalanceVal,
											Double.parseDouble(NiItemVal));
								else {
									currentCalculatedBalanceVal1 = "0";
								}
								// String
								// currentCalculatedBalanceVal1=roundSubtractDecimal(currentCalculatedBalanceVal,
								// Double.parseDouble(NiItemVal));
								calculatedBalanceNormalizedDetailsList
										.get(strNIItemHeaderList
												.indexOf(getLongMonth(str_stamentdt)))
										.setValue(currentCalculatedBalanceVal1);
							}
						}
					}
				}
				if (mapOfValueDetails == null)
					showNIItemValueMapFlag = "false";
				else if (mapOfValueDetails.size() == 0)
					showNIItemValueMapFlag = "false";

				if (mapOfDepositValueDetails == null)
					showNIDepositItemValueMap = "false";
				else if (mapOfDepositValueDetails.size() == 0)
					showNIDepositItemValueMap = "false";

				internalMap.put("NIItemHeaderList", strNIItemHeaderList);
				internalMap.put("NIItemValueMap", mapOfValueDetails);
				internalMap.put("NIDepositItemValueMap",
						mapOfDepositValueDetails);
				internalMap.put("showNIItemValueMapFlag",
						showNIItemValueMapFlag);
				internalMap.put("showNIDepositItemValueMap",
						showNIDepositItemValueMap);
				internalMap.put("headerSize", strNIItemHeaderList.size());
				returnMap.put(account, internalMap);
			}// end for accidList
		}// end of if accidList is null
		LOGGER.info("-------------- getHeaderDetails ended -------------------");
		// return mapOfValueDetails;
		return returnMap;
	}

	private String getLongMonth(String shortMonthYear) {

		String LongMonth = "";
		String[] shortMonth = shortMonthYear.split("-");
		if ("Jan".equals(shortMonth[0])) {
			LongMonth = "January";
		} else if ("Feb".equals(shortMonth[0])) {
			LongMonth = "February";
		} else if ("Mar".equals(shortMonth[0])) {
			LongMonth = "March";
		} else if ("Apr".equals(shortMonth[0])) {
			LongMonth = "April";
		} else if ("May".equals(shortMonth[0])) {
			LongMonth = "May";
		} else if ("Jun".equals(shortMonth[0])) {
			LongMonth = "June";
		} else if ("Jul".equals(shortMonth[0])) {
			LongMonth = "July";
		} else if ("Aug".equals(shortMonth[0])) {
			LongMonth = "August";
		} else if ("Sep".equals(shortMonth[0])) {
			LongMonth = "September";
		} else if ("Oct".equals(shortMonth[0])) {
			LongMonth = "October";
		} else if ("Nov".equals(shortMonth[0])) {
			LongMonth = "November";
		} else if ("Dec".equals(shortMonth[0])) {
			LongMonth = "December";
		}
		return LongMonth + "-" + shortMonth[1];
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getAccountIDByFillingId(Integer filingId) {
		LOGGER.info("-------------- getAccountIDByFillingId started -------------------");
		HashMap<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("filingId", filingId);
		List<String> AccountList = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getAccountIDByFillingId,
						NIBankValues.class, parameters);
		LOGGER.info("-------------- getAccountIDByFillingId ended -------------------");
		return AccountList;
	}

	@SuppressWarnings("unchecked")
	@Override
	public NormalisedParserOutput getFirstParserOutputRecord(Integer filingId,
			String section, String poAsRepLabel) {
		LOGGER.info(" **Start- getFirstParserOutputRecord started ");
		NormalisedParserOutput normalisedParserOutput = new NormalisedParserOutput();
		HashMap<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("filingId", filingId);
		parameters.put("poSection", section);
		parameters.put("poAsRepLabel", poAsRepLabel);
		List<ParserOutput> parserOutputRecord = (ArrayList<ParserOutput>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getFirstParserOutputRecord,
						ParserOutput.class, parameters);
		if (parserOutputRecord != null) {
			for (ParserOutput parserOutput : parserOutputRecord) {
				normalisedParserOutput.setPoAsRepVal1(parserOutput
						.getPoAsRepVal1() != null ? parserOutput
						.getPoAsRepVal1().toString() : "");
				normalisedParserOutput.setPoAsRepVal2(parserOutput
						.getPoAsRepVal2() != null ? parserOutput
						.getPoAsRepVal2().toString() : "");
				normalisedParserOutput.setPoAsRepVal3(parserOutput
						.getPoAsRepVal3() != null ? parserOutput
						.getPoAsRepVal3().toString() : "");
				normalisedParserOutput.setPoAsRepVal4(parserOutput
						.getPoAsRepVal4() != null ? parserOutput
						.getPoAsRepVal4().toString() : "");
			}
		}
		LOGGER.info(" ** End- getFirstParserOutputRecord ended ");
		return normalisedParserOutput;
	}

	public static String roundAddDecimal(double d1, double d2) { 
		d1 = d1 + d2;
		int i1 = (int) (d1 * 100);
		d1 = (double) i1;
		d1 = (double) d1 / 100d;
		DecimalFormat decimalFormat = new DecimalFormat("###0.00");
		return decimalFormat.format(d1);
	}

	public static String roundSubtractDecimal(double d1, double d2) { 
		d1 = d1 - d2;
		int i1 = (int) (d1 * 100);
		d1 = (double) i1;
		d1 = (double) d1 / 100d;
		DecimalFormat decimalFormat = new DecimalFormat("###0.00");
		return decimalFormat.format(d1);
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void updateNormalizedLabelColumn(Integer filingId, Integer niItem,
			String niLabel, String section) {
		LOGGER.info("** Start-updateNormalizedLabelColumn methode NormalizationServiceImpl class");

		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", filingId);
		parameterMap.put("niItem", niItem);
		parameterMap.put("niLabel", niLabel);
		parameterMap.put("section", section);

		genericDaoImpl.updateByNamedQuery(
				NamedQueryName.updateNiItemAndNiLabel, ParserOutput.class,
				parameterMap);

		LOGGER.info("** End-updateNormalizedLabelColumn methode NormalizationServiceImpl class");

	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void updateCustomMapping(String nilLable, Integer niItem,
			Integer filingId, String section, String asrepLable) {

		LOGGER.info("** Start-updateCustomMapping methode NormalizationServiceImpl class");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("NIL_LABEL", nilLable);
		parameterMap.put("NI_ITEM", niItem);
		parameterMap.put("filing_id", filingId);
		parameterMap.put("po_section", section);
		parameterMap.put("po_as_rep_label", "%" + asrepLable + "%");
		genericDaoImpl.updateByNamedQuery(
				NamedQueryName.updateCustodianMapping, ParserOutput.class,
				parameterMap);

		LOGGER.info("** End-updateCustomMapping methode NormalizationServiceImpl class");

	}

	@Override
	public List<Object> getNormalizedDataForSupplementalInfo(String stmtFormat,
			int WqId, int fillingid) {
		LOGGER.info("** Start--getNormalizedDataForSupplementalInfo start");
		LOGGER.debug("getNormalizedData started with" + stmtFormat + WqId);
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingid);
		parameterMap.put("statementType", stmtFormat);
		List<Object> parserOutput = genericDaoImpl.findByNativeNamedQuery(
				NamedNativeQueryName.getNormalizedDataForSupplementalInfo,
				ParserOutput.class, parameterMap);
		LOGGER.info(" ** End--getNormalizedDataForSupplementalInfo completed with result");
		return parserOutput;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<String> getDistinctSubSectionByFilingId(Integer fillingId,
			String statementType) {
		LOGGER.info("** Start--getDistinctSubSectionByFilingId start");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("statementType", statementType);
		List<String> distinctSubSectionList = (ArrayList<String>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getDistinctSubSection,
						ParserOutput.class, parameterMap);
		LOGGER.info("** End--getDistinctSubSectionByFilingId End");
		return distinctSubSectionList;
	}

	@SuppressWarnings("unchecked")
	@Override
	public Map<String, Map<String, NormalizeViewForDebitACHCommand>> getBankHeaderDetailsForDebitACH(
			List<String> accountNumberList, Integer fillingId,
			String nil_section) {
		LOGGER.info("** Start--getBankHeaderDetailsForDebitACH start");
		DateFormat formatter = new SimpleDateFormat("MMM-yyyy");
		SimpleDateFormat sdf = new SimpleDateFormat("MM-dd-yyyy");
		Map<String, Map<String, NormalizeViewForDebitACHCommand>> returnBasedOnAccNo = new HashMap<String, Map<String, NormalizeViewForDebitACHCommand>>();
		if ((accountNumberList != null) && (accountNumberList.size() > 0)) {
			for (String accountNumber : accountNumberList) {
				// Here we get latest 3 statement dates based on account number
				// and nil section
				Map<String, Object> parameterMap = new HashMap<String, Object>();
				parameterMap.put("accountNumber", accountNumber);
				parameterMap.put("nil_section", nil_section);
				parameterMap.put("fillingId", fillingId);
				List<Date> stmtDateList = (ArrayList<Date>) (Object) genericDaoImpl
						.findByNativeNamedQuery(
								NamedNativeQueryName.getFirstThreeDistinctDate,
								NIBankValues.class, parameterMap);
				stmtDateList = Lists.reverse(stmtDateList);
				// Create Map that contain stmt date as key
				// NormalizeViewForDebitACHCommand as a value
				Map<String, NormalizeViewForDebitACHCommand> resultBasedOnDate = new LinkedHashMap<String, NormalizeViewForDebitACHCommand>();
				for (Date stmtDate : stmtDateList) {
					// Here we fetch data from NI Bank Values based on statement
					// date
					String str_stamentdt = formatter.format(stmtDate);
					String monthname = getLongMonth(str_stamentdt);
					/*
					 * Here we fetch Begining Balance based on ni_item=130 and
					 * statement date
					 */
					Map<String, Object> parametersForBegBalance = new HashMap<String, Object>();
					parametersForBegBalance.put("niItem", 130);
					parametersForBegBalance.put("filingId", fillingId);
					parametersForBegBalance.put("accountNumer", accountNumber);
					parametersForBegBalance.put("statementDate", stmtDate);
					List<NIBankValues> niBankValuesObjectList = (List<NIBankValues>) (Object) genericDaoImpl
							.findByNamedQuery(
									NamedQueryName.getBeginningBalance,
									NIBankValues.class, parametersForBegBalance);
					Double beginingBalance = 0.0;
					if (niBankValuesObjectList.size() > 0) {
						NIBankValues niBankValues = niBankValuesObjectList
								.get(0);
						beginingBalance = niBankValues.getNiValue();
					}
					Map<String, Object> parameters = new HashMap<String, Object>();
					parameters.put("filingId", fillingId);
					parameters.put("accountNumer", accountNumber);
					parameters.put("nilSection", nil_section);
					parameters.put("statementDate", stmtDate);
					List<NIBankValues> bankValuesList = (ArrayList<NIBankValues>) (Object) genericDaoImpl
							.findByNamedQuery(
									NamedQueryName.getNiBankValuesForDebitACH,
									NIBankValues.class, parameters);
					NormalizeViewForDebitACHCommand normalizeViewForDebitACHCommand = new NormalizeViewForDebitACHCommand();
					normalizeViewForDebitACHCommand
							.setBeginingBalance(beginingBalance);
					normalizeViewForDebitACHCommand.setStmtMonth(monthname);
					Map<String, Double> depositListMap = new LinkedHashMap<String, Double>();
					Map<String, Double> withdrawalsListMap = new LinkedHashMap<String, Double>();
					Map<String, Double> dailyCashBalanceListMap = new LinkedHashMap<String, Double>();
					List<String> stmtDateListForeachRow = new ArrayList<String>();
					for (NIBankValues niBankValues : bankValuesList) {
						if (!stmtDateListForeachRow.contains(sdf.format(
								niBankValues.getDebitAchDate()).toString())) {
							stmtDateListForeachRow.add(sdf.format(
									niBankValues.getDebitAchDate()).toString());
						}
						// NI_ITEM 2960 means Deposits coloumn
						if (niBankValues.getNiItem() == 2960) {
							depositListMap.put(
									sdf.format(niBankValues.getDebitAchDate())
											.toString(), niBankValues
											.getNiValue());
						}
						// NI_ITEM 2970 means Withdrawals coloumn
						if (niBankValues.getNiItem() == 2970) {
							withdrawalsListMap.put(
									sdf.format(niBankValues.getDebitAchDate())
											.toString(), niBankValues
											.getNiValue());
						}
						// NI_ITEM 2980 means Withdrawals coloumn
						if (niBankValues.getNiItem() == 2980) {
							dailyCashBalanceListMap.put(
									sdf.format(niBankValues.getDebitAchDate())
											.toString(), niBankValues
											.getNiValue());
						}
					}
					normalizeViewForDebitACHCommand.setDeposits(depositListMap);
					normalizeViewForDebitACHCommand
							.setWithdrwals(withdrawalsListMap);
					normalizeViewForDebitACHCommand
							.setDailyCashBalance(dailyCashBalanceListMap);
					normalizeViewForDebitACHCommand
							.setStmtDate(stmtDateListForeachRow);
					resultBasedOnDate.put(monthname,
							normalizeViewForDebitACHCommand);
					LOGGER.info("** Data=="
							+ normalizeViewForDebitACHCommand.toString());
				}// End statement date loop
				returnBasedOnAccNo.put(accountNumber, resultBasedOnDate);
			}// End Account Number loop
		}
		LOGGER.info("** End--getBankHeaderDetailsForDebitACH start");
		return returnBasedOnAccNo;
	}

	public void downloadCRTemplate(
			Map<String, List<NormalisedLabelAndValues>> normalzedLabelsDetailsMap,
			String oparationName, String customerName,
			String downloadedCRTemplatePath, String CRTemplateFilePath,
			Map<String, List<String>> mapOfHeaders) {
		LOGGER.info("** Start--downloadCRTemplate start");
		try {
			/*
			 * Create copy of main file to another file
			 */
			String mainFilename = CRTemplateFilePath;
			String filePathToDownload = downloadedCRTemplatePath
					+ customerName + ".xlsm";
			File fileToCopy = new File(mainFilename).getCanonicalFile();
			File fileToWrite = new File(filePathToDownload).getCanonicalFile();
			FileUtils.copyFile(fileToCopy, fileToWrite);
			/*
			 * End copy file code
			 */
			FileInputStream fis = new FileInputStream(filePathToDownload);
			XSSFWorkbook book = new XSSFWorkbook(fis);
			XSSFSheet sheet = book.getSheetAt(4);
			/*
			 * Insert all item lables value and their row number from excel in
			 * Map
			 */
			Map<String, List<NormalizedDetails>> lableAndValueMap = new LinkedHashMap<String, List<NormalizedDetails>>();
			for (Map.Entry<String, List<NormalisedLabelAndValues>> normalisedLabelAndValues : normalzedLabelsDetailsMap
					.entrySet()) {
				List<NormalisedLabelAndValues> normLableList = normalisedLabelAndValues
						.getValue();
				for (NormalisedLabelAndValues normlableObj : normLableList) {
					if ((!normlableObj.getHeader().equalsIgnoreCase("Y") && !normlableObj
							.getDisplayFormat().equalsIgnoreCase("B"))
							|| (normlableObj.getHeader().equalsIgnoreCase("A"))) {
						lableAndValueMap.put(normlableObj.getLabel(),
								normlableObj.getList());
					}
				}
			}
			/*
			 * start-- Here we get Statement Date and Periods from Map of header
			 */
			for (Map.Entry<String, List<String>> stmtDateAndPeriods : mapOfHeaders
					.entrySet()) {
				String mapOfHeadersKey = stmtDateAndPeriods.getKey();
				if (mapOfHeadersKey.equalsIgnoreCase("Statement Date")) {
					List<NormalizedDetails> normalizedDetailsList = new ArrayList<NormalizedDetails>();
					for (String dateObj : stmtDateAndPeriods.getValue()) {
						NormalizedDetails normalizedDetailsObj = new NormalizedDetails();
						normalizedDetailsObj.setValue(dateObj);
						normalizedDetailsList.add(normalizedDetailsObj);
					}
					lableAndValueMap.put("Fiscal Year End",
							normalizedDetailsList);
				} else if (mapOfHeadersKey.equalsIgnoreCase("Periods")) {
					List<NormalizedDetails> normalizedDetailsList = new ArrayList<NormalizedDetails>();
					for (String periodsObj : stmtDateAndPeriods.getValue()) {
						NormalizedDetails normalizedDetailsObj = new NormalizedDetails();
						normalizedDetailsObj.setValue(periodsObj);
						normalizedDetailsList.add(normalizedDetailsObj);
					}
					lableAndValueMap.put("Periods", normalizedDetailsList);
				}
			}
			/*
			 * End-- Here we get Statement Date and Periods from Map of header
			 */

			/*
			 * Start-Itarate complete excel and put lable and row number in map
			 */
			Iterator<Row> itr = sheet.iterator();
			int rowNum = 1;
			Map<String, Integer> sheetRowsMap = new LinkedHashMap<String, Integer>();
			while (itr.hasNext()) {
				Row row = itr.next();
				// Iterating over each column of Excel file
				Iterator<Cell> cellIterator = row.cellIterator();
				while (cellIterator.hasNext()) {
					Cell cell = cellIterator.next();
					switch (cell.getCellType()) {
					case Cell.CELL_TYPE_STRING:
						if (cell.getColumnIndex() == 1) {
							/*
							 * Remove leading spaces from label
							 */
							sheetRowsMap.put(cell.getStringCellValue().trim(),
									rowNum);
						}
						break;
					case Cell.CELL_TYPE_NUMERIC:

						break;
					case Cell.CELL_TYPE_BOOLEAN:

						break;
					default:

					}
				}

				rowNum++;
			}
			/*
			 * End--Itarate complete excel and put lable and row number in map
			 */
			for (Map.Entry<String, List<NormalizedDetails>> dataEntry : lableAndValueMap
					.entrySet()) {
				String dataKey = dataEntry.getKey();
				Object[] dataVal = new Object[dataEntry.getValue().size()];
				int i = 0;
				for (NormalizedDetails lableValues : dataEntry.getValue()) {
					if(lableValues!=null){
					if (lableValues.getValue() != null) {
						if (dataKey.equalsIgnoreCase("Fiscal Year End")
								|| dataKey.equalsIgnoreCase("Periods")) {
							dataVal[i] = (String) lableValues.getValue();
						} else {
							dataVal[i] = (String) lableValues.getValue();
						}
					}
					}
					if (dataVal[i] == null) {
						dataVal[i] = "";
					}
					i++;
				}
			
				Integer rowNumSheet = sheetRowsMap.get(dataKey);
				if (rowNumSheet != null) {
					Row row = sheet.getRow(rowNumSheet - 1);
					if (dataKey.equalsIgnoreCase("Fiscal Year End")
							|| dataKey.equalsIgnoreCase("Periods")) {
						for (int k = 1; k < dataVal.length + 1; k++) {
							Cell cell = row.getCell(k + 1);
							cell.setCellValue((String) dataVal[k - 1].toString());
						}
					} else {
						for (int k = 1; k < dataVal.length + 1; k++) {
							Cell cell = row.getCell(k + 1);
							if (oparationName.equalsIgnoreCase("Actuals")) {
								if(dataVal[k - 1]!=null){
								if (!((String) dataVal[k - 1])
										.equalsIgnoreCase("")) {
									cell.setCellValue((Double) (Double
											.valueOf((String) dataVal[k - 1].toString().replace(",", "")) / 1000));
								} else {
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
								}else{
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
							} else if (oparationName
									.equalsIgnoreCase("Millions")) {
								if(dataVal[k - 1]!=null){
								if (!((String) dataVal[k - 1])
										.equalsIgnoreCase("")) {
									cell.setCellValue((Double) (Double
											.valueOf((String) dataVal[k - 1].toString().replace(",", "")) * 1000));
								} else {
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
								}else{
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
							} else if (oparationName
									.equalsIgnoreCase("Billions")) {
								if(dataVal[k - 1]!=null){
								if (!((String) dataVal[k - 1])
										.equalsIgnoreCase("")) {
									cell.setCellValue((Double) (Double
											.valueOf((String) dataVal[k - 1]) * 1000000));
								} else {
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
							} else {
								if(dataVal[k - 1]!=null){
								if (!((String) dataVal[k - 1])
										.equalsIgnoreCase("")) {
									cell.setCellValue((Double) (Double.valueOf((String) dataVal[k - 1].toString().replace(",", ""))));
								} else {
									cell.setCellType(Cell.CELL_TYPE_BLANK);
								}
							}else{
								cell.setCellType(Cell.CELL_TYPE_BLANK);
							}
						 }	
						}// end for

					}// end else
				}
			}
			}//end for
			// open an OutputStream to save written data into Excel file
			FileOutputStream os = new FileOutputStream(filePathToDownload);
			book.setForceFormulaRecalculation(true);
			book.write(os);
			LOGGER.info("Writing on Excel file Finished.");
			os.close();
			fis.close();
			LOGGER.info("** End--downloadCRTemplate start");
		} catch (FileNotFoundException fe) {
			fe.printStackTrace();
			LOGGER.error("Error:" + fe);
		} catch (IOException ie) {
			ie.printStackTrace();
			LOGGER.error("Error:" + ie);
		} catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:" + e);
		}
	}

	@Override
	public List<NormItemLabels> getIndustryName(int templateId) {
		List<NormItemLabels> LableNameTid = new ArrayList<NormItemLabels>();
		try {
			List<Object> nilIndustryNameAndId = null;
			HashMap<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("templateId", templateId);
			nilIndustryNameAndId = genericDaoImpl.findByNamedQuery(
					NamedQueryName.getNormalizationLableName,
					NormItemLabels.class, parameters);
			for (Object object : nilIndustryNameAndId) {
				Object[] obj = (Object[]) object;
				NormItemLabels Nil = new NormItemLabels();
				Nil.setTemplateId(obj[0] == null ? 0 : Integer.parseInt(obj[0]
						.toString()));
				Nil.setNilIndustry(obj[1] == null ? "" : obj[1].toString());
				LableNameTid.add(Nil);
			}
		} catch (Exception e) {
			LOGGER.error("Exception Occured class:NormalizationServiceImpl" + e);
		}
		return LableNameTid;
	}

	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.RAGE_TX_MANAGER)
	public Integer getNextSequenceValue() {
		BigDecimal nextSeqVal = null;
		LOGGER.info("--- ** -start--getNextSequenceValue -------");
		List<Object> resultList = (ArrayList<Object>) (Object) genericDaoImpl
				.findByNativeNamedQuery(
						NamedNativeQueryName.getNexSequencValue,
						ExtractorTableidRouteByCik.class);
		nextSeqVal = (BigDecimal) resultList.get(0);
		LOGGER.info("--- ** -End--getNextSequenceValue -------");
		return nextSeqVal.intValue();
	}


	@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public int getTemplateIdByFilingIdFromFiling(int filingId) {
		LOGGER.info("** start---getTemplateIdByFilingFromFiling methode");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", filingId);
		Filings filings = genericDaoImpl.findByColumn(
				NamedQueryName.getTemplateId, Filings.class, parameterMap);

		if (filings.getTemplateId() != null) {
			LOGGER.info("** template id=" + filings.getTemplateId());
			return filings.getTemplateId();
		}
		return 0;
	}

	@Override
	public Map<String, List<PdfExtractionMetadatCommand>> f_getPDFExtMetadata(
			Integer filingId) {
		LOGGER.info("** start-- f_getPDFExtMetadata()");
		Map<String, List<PdfExtractionMetadatCommand>> resultMap = new LinkedHashMap<String, List<PdfExtractionMetadatCommand>>();
		try {
			List<PdfExtractionMetadata> extractor_rule_list = extractionService
					.getPdfBasedExtractionRuleByFilingId(filingId,"display");

			List<String> unsortedSectionList = new ArrayList<String>();

			for (PdfExtractionMetadata extractionMetadata : extractor_rule_list) {
				unsortedSectionList.add(extractionMetadata.getPemSection());
			}

			List<String> sortedSectionList = new ArrayList<String>(
					new LinkedHashSet<String>(unsortedSectionList));
			List<String> sortOrder = new ArrayList<String>();
			sortOrder.add("IS");
			sortOrder.add("BS");
			sortOrder.add("CF");
			sortOrder.add("Other");

			Collections.sort(sortedSectionList, new SectionWiseComparator(
					sortOrder));

			for (String section : sortedSectionList) {
				List<PdfExtractionMetadatCommand> extrMetaComndsObjList = new ArrayList<PdfExtractionMetadatCommand>();
				for (PdfExtractionMetadata extractionMetadata : extractor_rule_list) {
					if (section.equalsIgnoreCase(extractionMetadata
							.getPemSection())) {
						PdfExtractionMetadatCommand extractionMetadatCommand = new PdfExtractionMetadatCommand();
						extractionMetadatCommand
								.setBeginKeyword(extractionMetadata
										.getPemBeginKeyword());
						extractionMetadatCommand.setSection(extractionMetadata
								.getPemSection());
						extractionMetadatCommand.setTableId(extractionMetadata
								.getPemTableId());
						extractionMetadatCommand.setBeginPageNumber(extractionMetadata.getPemBeginPageNo());
						extrMetaComndsObjList.add(extractionMetadatCommand);

					}

				}
				resultMap.put(section, extrMetaComndsObjList);

			}

		} catch (Exception e) {
			LOGGER.error("Error:", e);
			e.printStackTrace();
		}
		return resultMap;
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public String f_mergePdfBasedParser(String checkboxArray, int filingId) {
		LOGGER.info("**start--f_mergePdfBasedParser() methode");
		/**
		 * from here we have called two methods one for update parser_output
		 * table and second is populate entry in rquest_queue table for engine
		 * mode query
		 * 
		 */
		boolean statusFlag = false;
		String msg = "";
		try {
			User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
			String array[] = checkboxArray.split(",");
			for (int i = 0; i < array.length; i++) {
				statusFlag = false;
				String value = array[i];
				String rowValue[] = value.split("~");
				HashMap<String, Object> parameters = new HashMap<String, Object>();

				parameters.put("poTableId", rowValue[0]);
				parameters.put("poSection", rowValue[1]);
				parameters.put("poMerge", rowValue[2]);
				parameters.put("fillingId", filingId);

				genericDaoImpl.updateByNamedQuery(
						NamedQueryName.updatePoMergeCloumn, ParserOutput.class,
						parameters);
				statusFlag = true;
			}

			if (statusFlag) {
				/**
				 * if status flag is true then call rage process based on filing
				 * id.
				 */
				Integer requestId =extractionService.saveToRequestQueueByFilingId(filingId,segmentMerge);
				saveInvokeProcessTracker(requestId,filingId,"N",segmentMerge,user.getUserId());
				updateWqStatusByFilingId(filingId, "Processing");
				msg = "PDF based parser merging has been done successfully";
			} else {
				msg = "PDF based parser merging failed";
			}

		} catch (ArrayIndexOutOfBoundsException aioe) {
			aioe.printStackTrace();
			LOGGER.error("ArrayIndexOutOfBoundsException:", aioe);
		} catch (NullPointerException npe) {
			npe.printStackTrace();
			LOGGER.error("NullPointerException:", npe);
		} catch (IllegalArgumentException iae) {
			iae.printStackTrace();
			LOGGER.error("IllegalArgumentException:", iae);
		} catch (Exception e) {

			e.printStackTrace();
			LOGGER.error("Error:", e);
		}
		LOGGER.info("**end--f_mergePdfBasedParser() methode");

		return msg;
	}

	@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public boolean f_deleteStatementData(String checkboxArray, Integer filingId) {

		boolean deleteFlag = false;
		try {

			LOGGER.info("**Start--f_deleteStatementData() methode");
			String array[] = checkboxArray.split(",");
			for (int i = 0; i < array.length; i++) {
				String value = array[i];
				String tableId[] = value.split("~");
				/**
				 * This code used for delete records from pdf extraction
				 * metadata table
				 */
				boolean pdfMetadataflag = extractionService.f_deletePdfExtractionMetataDataByfilingId(filingId,Integer.parseInt(tableId[0]));
				/**
				 * This code used for delete records from parser output table
				 */
				if (pdfMetadataflag) {
					HashMap<String, Object> parametersView = new HashMap<String, Object>();
					parametersView.put("tableId", tableId[0]);
					parametersView.put("filingId", filingId);
					genericDaoImpl.removeByNamedQuery(NamedQueryName.deleteParserOutput_ByFilingIdAndTableId,ParserOutput.class, parametersView);
					deleteFlag = true;
				}

			}// end for
		} catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:", e);
			deleteFlag = false;
		}

		return deleteFlag;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutput> getNormalizedDataForDealerFormParser(String stmtFormat,
			int WqId, int fillingId,Integer startNum,Integer endNum) {
		LOGGER.info("getNormalizedDataForDealerFormParser started");
		LOGGER.debug("getNormalizedDataForDealerFormParser started with"
				+ stmtFormat + WqId);
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("statementType", stmtFormat);
		parameterMap.put("start", startNum);
		parameterMap.put("end", endNum);


		List<ParserOutput> parserOutput = (List<ParserOutput>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNormalizedDataByFilingIdandStatementType_Q1,ParserOutput.class, parameterMap);

		LOGGER.info("getNormalizedDataForDealerFormParser completed with result");
		return parserOutput;
	}

	/**
	 * This methode used for get highest year,month,date and period then update
	 * WQ_MONTH_YEAR and WQ_PERIOD from work_queue table
	 */
	public int updateWorkQueueForMonthAndYear(Integer fillingId, String section) {
		LOGGER.info("**start-updateWorkQueueForMonthAndYear methode");
		int updateFlag = 0;
		try {
			Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("filingId", fillingId);
			parameterMap.put("section", section);

			List<Object> stmtAttrObjList = genericDaoImpl
					.findByNativeNamedQuery(
							NamedNativeQueryName.getStmtAttrLableList,
							ParserOutput.class, parameterMap);
			if(!CollectionUtils.isEmpty(stmtAttrObjList))
			{
				LOGGER.info("List size:" + stmtAttrObjList.size());
			}

			/**
			 * Store horizontal records into vertical format
			 */
			ArrayList<String> stmtLabel = new ArrayList<String>();
			ArrayList<Integer> stmtYear = new ArrayList<Integer>();
			ArrayList<String> stmtMonth = new ArrayList<String>();
			ArrayList<Integer> stmtdate = new ArrayList<Integer>();
			ArrayList<Integer> stmtPeriod = new ArrayList<Integer>();
			for (Object object : stmtAttrObjList) {
				Object[] obj = (Object[]) object;

				stmtLabel.add(obj[0] == null ? "" : obj[0].toString());
				if (obj[0].toString().equalsIgnoreCase("STATEMENT YEAR")) {
					stmtYear.add(obj[1] == null ? 0 : obj[1].toString().isEmpty() ? 0 : Integer.parseInt(obj[1].toString()));
					stmtYear.add(obj[2] == null ? 0 : obj[2].toString().isEmpty() ? 0 : Integer.parseInt(obj[2].toString()));
					stmtYear.add(obj[3] == null ? 0 : obj[3].toString().isEmpty() ? 0 : Integer.parseInt(obj[3].toString()));
					stmtYear.add(obj[4] == null ? 0 : obj[4].toString().isEmpty() ? 0 : Integer.parseInt(obj[4].toString()));
				} else if (obj[0].toString()
						.equalsIgnoreCase("STATEMENT MONTH")) {
					stmtMonth.add(obj[1] == null ? "" : obj[1].toString().isEmpty() ? "" : obj[1].toString());
					stmtMonth.add(obj[2] == null ? "" : obj[2].toString().isEmpty() ? "" : obj[2].toString());
					stmtMonth.add(obj[3] == null ? "" : obj[3].toString().isEmpty() ? "" : obj[3].toString());
					stmtMonth.add(obj[4] == null ? "" : obj[4].toString().isEmpty() ? "" : obj[4].toString());
				} else if (obj[0].toString().equalsIgnoreCase("STATEMENT DATE")) {
					stmtdate.add(obj[1] == null ? 0 : obj[1].toString().isEmpty() ? 0 : Integer.parseInt(obj[1].toString()));
					stmtdate.add(obj[2] == null ? 0 : obj[2].toString().isEmpty() ? 0 : Integer.parseInt(obj[2].toString()));
					stmtdate.add(obj[3] == null ? 0 : obj[3].toString().isEmpty() ? 0 : Integer.parseInt(obj[3].toString()));
					stmtdate.add(obj[4] == null ? 0 : obj[4].toString().isEmpty() ? 0 : Integer.parseInt(obj[4].toString()));
				} else if (obj[0].toString().equalsIgnoreCase(
						"STATEMENT PERIOD")) {
					stmtPeriod.add(obj[1] == null ? 0 : obj[1].toString().isEmpty() ? 0 : Integer.parseInt(obj[1].toString()));
					stmtPeriod.add(obj[2] == null ? 0 : obj[2].toString().isEmpty() ? 0 : Integer.parseInt(obj[2].toString()));
					stmtPeriod.add(obj[3] == null ? 0 : obj[3].toString().isEmpty() ? 0 : Integer.parseInt(obj[3].toString()));
					stmtPeriod.add(obj[4] == null ? 0 : obj[4].toString().isEmpty() ? 0 : Integer.parseInt(obj[4].toString()));
				}
			}
		
			
		
			/**
			 * @Start- update work_queue table code
			 */
			GetMaxYearMonthAndPeriod getMaxYearMonthAndPeriod=new GetMaxYearMonthAndPeriod();
			Map<String,String> resultMap=getMaxYearMonthAndPeriod.getMaxYearMonthAndPreiod(stmtYear, stmtMonth, stmtdate, stmtPeriod);
		
			String year=resultMap.get("year");
			String month=resultMap.get("monthName");
			String wq_period=resultMap.get("period");
			String wq_monthyear="";
			 String period="";
			 if(!wq_period.equalsIgnoreCase("0")){
				 period=wq_period;
			 }
			if(month!=null){
			 wq_monthyear = month+" "+year;
			}else{
			 wq_monthyear=year;
			}
			
	
			updateFlag = workQueueService.f_updateMonthYearAndPeriod(
					wq_monthyear, period, fillingId);
			/**
			 * @End- update WQ_PERIOD and WQ_MONTH_YEAR column from work_queue
			 *       table code
			 */

		} catch (Exception e) {
			LOGGER.error("ERROR:", e);
			e.printStackTrace();
		}
		LOGGER.info("**end-updateWorkQueueForMonthAndYear methode");

		return updateFlag;
	}

	@Override
	public Integer f_getMaxTransactionId() {
		
		Integer maxTransationId=1;
	 
		try{
		List<Object> list = genericDaoImpl.findByNamedQuery(NamedQueryName.getMaxTransactionId, ParserOutputAudit.class);
		List<Integer> maxTempleVal = new ArrayList<Integer>();
		for (Object object : list) {
			maxTempleVal.add(object != null ? Integer.parseInt(object.toString()) : 0);
			maxTransationId=maxTempleVal.get(0)+1;
		}
		}catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:",e);
		}	
		return maxTransationId;
		
	}
	
	public boolean isAnychangesFromUI(ParserOutput parserOutputNew,ParserOutput parserOutputOld){

		boolean flag=false;
		try{
			if(parserOutputNew.equals(parserOutputOld)){
				 flag=true;
			}
		}catch (Exception e) {
		LOGGER.error("Error:",e);
		}
	
		return flag;
	}

	@SuppressWarnings("unchecked")
	@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public Map<String,String> f_fetchSectionListByFilingId(Integer filingId,Integer parserId) {
		LOGGER.info("** start--f_fetchSectionListByFilingId methode");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		Map<String, String> sectionListMap=new LinkedHashMap<String, String>();
		parameterMap.put("fillingId", filingId);
       
		/**
		 * Here if parser is dealer form (parser id=18) then fetch records from only parser_output table 
		 */
		
	  if(parserId!=18){
		List<SectionMappingModel> sectionMappingList=new ArrayList<SectionMappingModel>();
		sectionMappingList=((List<SectionMappingModel>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getSectionMappingListByFilingId, SectionMappingModel.class, parameterMap));
       for(SectionMappingModel sectionMappingModel:sectionMappingList){
    	sectionListMap.put(sectionMappingModel.getSectionName(), sectionMappingModel.getSectionDisplayName());
       }
	   }else{
		   List<Object> ObjectList =genericDaoImpl.findByNamedQuery(NamedQueryName.getDistinctSectionListByFilingId, ParserOutput.class,parameterMap);
		   for(Object object:ObjectList){
			   if((object== null ? "" : object.toString()).equalsIgnoreCase("DOS")){
			   sectionListMap.put(object == null ? "" : object.toString(), "Dealer Operating Statement");   
			   }else{
			   sectionListMap.put(object == null ? "" : object.toString(), object == null ? "" : object.toString());
			   }
		   }
	   }
       	
       	LOGGER.info("** end--f_fetchSectionListByFilingId methode");
		return sectionListMap;
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public boolean f_saveInLanguageMappingMetadata(List<Integer> poIdList) {
		LOGGER.info("**start--f_saveInLanguageMappingMetadata() started");
		
		boolean flag=false;
		try{
		List<LanguageMappingMetadata> languageMappingMetadataList=new ArrayList<LanguageMappingMetadata>();
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poIdList", poIdList);
		
		List<Object> objectList=genericDaoImpl.findByNamedQuery(NamedQueryName.fetchParserOutputForLanguageMapping, ParserOutput.class,parameterMap);
		for(Object object:objectList){
			LanguageMappingMetadata languageMappingMetadata=new LanguageMappingMetadata();
			Object[] obj = (Object[]) object;
			languageMappingMetadata.setEnglishLabel(obj[1] == null ? "" : obj[1].toString());
			languageMappingMetadata.setSection(obj[2] == null ? "" : obj[2].toString());
			languageMappingMetadata.setNonEnglishLabel(obj[3] == null ? "" : obj[3].toString());
			languageMappingMetadata.setLanguage(obj[4] == null ? "" : obj[4].toString());
			languageMappingMetadataList.add(languageMappingMetadata);
		 }
		   genericDaoImpl.persist(languageMappingMetadataList);
		   flag=true;
		}catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:"+e);
		} 
		LOGGER.info("**end--f_saveInLanguageMappingMetadata() end");
		return flag;
	}

	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public List<ParserOutput> f_fetchParserOutputByNormLabel(Integer filingId,String levelName, List<String> sectionList) {
		LOGGER.info("**Start--f_fetchParserOutputByNormLabel() fucction");
		List<ParserOutput> parserOutputList=new ArrayList<ParserOutput>();
		try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", filingId);
		parameterMap.put("sectionList", sectionList);
		if(!StringUtils.isEmpty(levelName)){
				if (levelName.equalsIgnoreCase("GlobalLevel")) {
					parserOutputList = (List<ParserOutput>) (Object) genericDaoImpl.findByNamedQuery(
							NamedQueryName.getParserOutputByNormLabelGlobalData, ParserOutput.class, parameterMap);
				}
				else if (levelName.equalsIgnoreCase("IndustryLevel")) {
					parserOutputList = (List<ParserOutput>) (Object) genericDaoImpl.findByNamedQuery(
							NamedQueryName.getParserOutputByNormLabelIndustryData, ParserOutput.class, parameterMap);
				}else {
					parserOutputList = (List<ParserOutput>) (Object) genericDaoImpl.findByNamedQuery(
							NamedQueryName.getParserOutputByNormLabelCompanyData, ParserOutput.class, parameterMap);
				}
		}
		}catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Error:", e);
		}
		LOGGER.info("**end--f_fetchParserOutputByNormLabel() fucction");
		
		return parserOutputList;
	}
	
	@Override
	public List<AsRepStatement>  getAsRepStmtByFilingId(Integer filingId,String stmtFormat){
		LOGGER.info("** Start-getAsRepStmtByFilingId methode NormalizationServiceImpl class");
		List<Object> objectList=normalizationViewDAO.getAsRepStmtByFilingId(filingId, stmtFormat);
		List<AsRepStatement> asRepStatementList =new ArrayList<AsRepStatement>();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		SimpleDateFormat sdf1 = new SimpleDateFormat("MM/dd/yyyy");
		try{
		for(Object object:objectList){
			AsRepStatement asRepStatement=new AsRepStatement();
			Object[] obj = (Object[]) object;
			asRepStatement.setArsDateStr(obj[0] == null ? "" :sdf.format(sdf1.parse(obj[0].toString())));
			asRepStatement.setArsId(obj[1] == null ? 0 : new Integer(obj[1].toString()));
			asRepStatement.setFilingId(obj[2] == null ? 0 : new Integer(obj[2].toString()));
			asRepStatement.setArsStmtYear(obj[3] == null ? 0 : new Integer(obj[3].toString()));
			asRepStatement.setArsPeriod(obj[4] == null ? 0 : new Integer(obj[4].toString()));
			asRepStatement.setArsAuditFlag(obj[5] == null ? "" : obj[5].toString());
			asRepStatementList.add(asRepStatement);
			
			
		 }
		}catch(Exception e){
			e.printStackTrace();
		}
		
		//To Add last section to map;
		
		LOGGER.info("** End-getAsRepStmtByFilingId methode NormalizationServiceImpl class");
		return asRepStatementList;
		
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<NormItemLabels> getListOfNormItemLabelsByTemplateId(String stmtFormat,
			Integer fillingId) {
		LOGGER.info("-------------- getListOfNormItemLabelsByTemplateId started -------------------");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("section", stmtFormat);
		Map<String, Object> parameterMapOne = new HashMap<String, Object>();
		parameterMapOne.put("filingId", fillingId);
		
		Filings templateId = genericDaoImpl.findByColumn(
				NamedQueryName.getTemplateId, Filings.class, parameterMapOne);
		parameterMap.put("templateId", templateId.getTemplateId());
		List<NormItemLabels> normItemLabelsList = null;
		if (templateId.getTemplateId() != null)
			normItemLabelsList = (ArrayList<NormItemLabels>) (Object) genericDaoImpl
					.findByNamedQuery(
							NamedQueryName.getNormItemLabelsListByTemplate,
							NormItemLabels.class, parameterMap);
		LOGGER.info("-------------- getListOfNormItemLabelsByTemplateId ended -------------------");
		return normItemLabelsList;
	}
	
	private Map<Integer,ParserOutput> getParserOutputMap(NormalizeFormData normalizeFormData){
		try{
			Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("poIdList", normalizeFormData.getAddPoId());
			List<Object> objectList=genericDaoImpl.findByNamedQuery(NamedQueryName.getPoIdArslabelByPoIdList, ParserOutput.class,parameterMap);
			Map<Integer,ParserOutput> parserOutputMap = new LinkedHashMap<Integer, ParserOutput>();
			ParserOutput parserOutput = null;
			Integer poId=0;
			if(!CollectionUtils.isEmpty(objectList))
			{
				for(Object object:objectList){
					parserOutput=new ParserOutput();
					
					Object[] obj = (Object[]) object;
					poId=obj[0] != null ? new Integer(obj[0].toString()) : 0;
					parserOutput.setPoId(poId);
					parserOutput.setPoAsRepLabel(obj[1] == null ? "" : obj[1].toString());
					parserOutput.setPoSubSection(obj[2] == null ? "" : obj[2].toString());
					parserOutput.setPoSection(obj[3] == null ? "" : obj[3].toString());
					parserOutputMap.put(poId, parserOutput);
					
				 }
				return parserOutputMap;
			}
			
			return null;
		}catch(Exception e){
			 e.printStackTrace();
				return null;
		 }
	}
	
	@SuppressWarnings("unchecked")
	private List<FinancialItems> getFinancialItems(NormalizeFormData normalizeFormData,ParserOutput parserOutput){
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		
		try{
			parameterMap.put("templateId", normalizeFormData.getTemplateId());
			parameterMap.put("asRepLabel", parserOutput.getPoAsRepLabel().trim());
			parameterMap.put("fiSection", parserOutput.getPoSection());
			parameterMap.put("fiSubSection", parserOutput.getPoSubSection());
			parameterMap.put("niItem", normalizeFormData.getNormLableId());
			List<FinancialItems> financialItemList = (ArrayList<FinancialItems>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.findFinancialItemListByParserOutPut, FinancialItems.class,parameterMap);
			return financialItemList;
		}catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public boolean  updateNormalizedLabelByPoID(NormalizeFormData normalizeFormData) {
		LOGGER.info("** Start-updateNormalizedLabelByPoID methode NormalizationServiceImpl class");
		boolean flag=false;
		
		try{
		
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("normLabelId", normalizeFormData.getNormLableId());
		parameterMap.put("normLabel", normalizeFormData.getNormLable());
		Map<Integer,ParserOutput> parserOutputMap=null;
		
		if(!CollectionUtils.isEmpty(normalizeFormData.getAddPoId()) && normalizeFormData.geteId()!=null){
			parserOutputMap=getParserOutputMap(normalizeFormData);
		}
		Integer templateId=null;
		if(!CollectionUtils.isEmpty(parserOutputMap)){
			Map<String, Object> filingsParameterMap = new HashMap<String, Object>();
			filingsParameterMap.put("filingId", normalizeFormData.getFillingId());
			Filings filings = genericDaoImpl.findByColumn(
					NamedQueryName.getTemplateId, Filings.class, filingsParameterMap);
			templateId= filings.getTemplateId();
			
		}
		ParserOutput parserOutput = null;
		Integer poId=null;
		String mappingName=null;
		Integer fiId=null;
		Integer eId=normalizeFormData.geteId();
		
		Map<String,Object> normLabelSubSectionParameterMap= new HashMap<String,Object>();
		normLabelSubSectionParameterMap.put("templateId", templateId);
		normLabelSubSectionParameterMap.put("niItem", normalizeFormData.getNormLableId());
		List<Object> subSectionData = genericDaoImpl.findByNamedQuery(NamedQueryName.getNrmItmLblSubSectionByTmplteNiItem, NormItemLabels.class,normLabelSubSectionParameterMap);
		String subSection="";
		String subSectionParam="";
		if(!CollectionUtils.isEmpty(subSectionData)){
			subSection=subSectionData.get(0)!=null?subSectionData.get(0).toString().trim():null;
			normalizeFormData.setSubSection(subSection!=null?subSection:"");
		}
		
		for(int i=0;i<normalizeFormData.getAddPoId().size();i++){
		
			ParserOutputAuditTrail parserOutputAuditTrailOrignal = getOriginalPORecordToPOATRecord(normalizeFormData,normalizeFormData.getAddPoId().get(i));
			if(parserOutputAuditTrailOrignal!=null){
				parserOutputAuditTrailOrignal.setPoCrudStatus("O");
				genericDaoImpl.persist(parserOutputAuditTrailOrignal);
			}
			
			poId=normalizeFormData.getAddPoId().get(i);
			
			if(!CollectionUtils.isEmpty(parserOutputMap)){
				parserOutput=parserOutputMap.get(poId);
				
				if(normalizeFormData!=null && parserOutput!=null){
					if(null==parserOutput.getPoSubSection() || parserOutput.getPoSubSection().trim().equalsIgnoreCase("")){
						parserOutput.setPoSubSection(subSection);
						subSectionParam=subSection;
					}else{
						subSectionParam=parserOutput.getPoSubSection();
					}
					if(!StringUtils.isEmpty(parserOutput.getPoAsRepLabel()) && !StringUtils.isEmpty(parserOutput.getPoSection()) && templateId!=null && normalizeFormData.getNormLableId()!=null){
						normalizeFormData.setTemplateId(templateId);
						
						List<FinancialItems> financialItemList = getFinancialItems(normalizeFormData,parserOutput);
						if(!CollectionUtils.isEmpty(financialItemList)){
							for(FinancialItems financialItems :financialItemList){
								if(null!=financialItems.geteId() && eId.equals(financialItems.geteId())){
									mappingName=financialItems.getFiSearchType();
									fiId=financialItems.getFiId();
									break;
								}else if(null == financialItems.geteId() || financialItems.geteId().equals(0)){
									mappingName=financialItems.getFiSearchType();
									fiId=financialItems.getFiId();
								}
							}
						}
					}
				}
			}
			
			
			
			parameterMap.put("poId", poId);
			parameterMap.put("mappingType","MANUAL");
			parameterMap.put("poCrudAccount","U");
			parameterMap.put("mappingName",mappingName);
			parameterMap.put("fiId",fiId);
			
			//here if parser is ITR the no need to update po_subsection in parser_output table
			// ITR also update po_subsection also
			if(normalizeFormData.getParserId()!=null){
				parameterMap.put("poSubSection",subSectionParam);
				genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNormLabelByPoId, ParserOutput.class,parameterMap);	
			}
			
			ParserOutputAuditTrail parserOutputAuditTrailNew = getOriginalPORecordToPOATRecord(normalizeFormData,normalizeFormData.getAddPoId().get(i));
			if(parserOutputAuditTrailNew!=null){
				parserOutputAuditTrailNew.setNiItem(normalizeFormData.getNormLableId());
				parserOutputAuditTrailNew.setNilLabel(normalizeFormData.getNormLable());
				parserOutputAuditTrailNew.setCategory("NI_ITEM,NIL_LABEL");
				parserOutputAuditTrailNew.setPoCrudStatus("U");
				parserOutputAuditTrailNew.setPoSubSection(subSection);
				genericDaoImpl.persist(parserOutputAuditTrailNew);
			}
			flag=true;
		}
		}catch (Exception e) {
			e.printStackTrace();
		flag=false;
		LOGGER.error("** Error in updateNormalizedLabelByPoID methode:",e);
		}
		LOGGER.info("** End-updateNormalizedLabelByPoID methode NormalizationServiceImpl class");
		return flag;
	}
	
	
	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void  createArsPoMapping(ArsPoMapping arsPoMapping,NIValues niValues) {
		LOGGER.info("** Start-createArsPoMapping methode NormalizationServiceImpl class");

		Map<String, Object> parameterMap = new HashMap<String, Object>();
		List<NIValues> niValuesRecordList=null;
		Map<String, Object> NIValueparameterMap = null;
		
		parameterMap.put("poId", arsPoMapping.getPoId());
		parameterMap.put("fillingId", arsPoMapping.getFillingId());
		parameterMap.put("arsId", arsPoMapping.getArsId());
		String colName = arsPoMapping.getPoColumnName();
		colName = colName.replace("child", ""); 
		parameterMap.put("poColumnName", colName);
		parameterMap.put("poColumnVal", arsPoMapping.getPoColumnVal());
		parameterMap.put("niItem", arsPoMapping.getNiItem());
		parameterMap.put("nilLabel", arsPoMapping.getNilLabel());
		
		parameterMap.put("headerLabel", arsPoMapping.getHeaderLabel());
		parameterMap.put("tableLabel", arsPoMapping.getTableLabel());
		parameterMap.put("section", arsPoMapping.getSection());
		parameterMap.put("subSection", arsPoMapping.getSubSection());
		
		StringBuilder tempRefPoId= new StringBuilder("");
		StringBuilder refPoId=new StringBuilder("");
		BigDecimal tempNIValue= new BigDecimal(0);
		String orignalColumnName="";
		String[] refPoIdArray = null;
		//To prepare refPOID for this mapping 
		if(arsPoMapping.getPoColumnName()!=null && arsPoMapping.getPoColumnName().contains("child")){
			orignalColumnName=arsPoMapping.getPoColumnName().substring(5);
		}else{
			orignalColumnName=arsPoMapping.getPoColumnName()!=null?arsPoMapping.getPoColumnName():"";
		}
		tempRefPoId.append(arsPoMapping.getPoId()).append("-PO_").append(orignalColumnName.toUpperCase());
		//end of preparing refPOID for this mapping 
		
		List<ArsPoMapping> arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getArsPoMappingRecordsByFILINGID,ArsPoMapping.class, parameterMap);
		ArsPoMapping arsPoMappingRecord= new ArsPoMapping();
		
		if(arsPoMappingRecordList!=null && arsPoMappingRecordList.size()>0){
			arsPoMappingRecord=arsPoMappingRecordList.get(0);
		}
		if(arsPoMappingRecord!=null && arsPoMappingRecord.getPoId()!=null){
			//to subtract existing NI value and map with new NI VAlue record
			HashMap<String, Object> oldArsNIValueparameterMap = new HashMap<String, Object>();
			oldArsNIValueparameterMap.put("fillingId", arsPoMapping.getFillingId());
			oldArsNIValueparameterMap.put("arsId", arsPoMappingRecord.getArsId());
			oldArsNIValueparameterMap.put("niItem", arsPoMappingRecord.getNiItem());
			niValuesRecordList = (ArrayList<NIValues>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNiValauesRecordByFILID,NIValues.class, oldArsNIValueparameterMap);
			
			//getting existing refPOID value and deleting existing mapping refPOID val
			if(niValuesRecordList!=null && niValuesRecordList.size()>0){
				NIValues nIValueRecord = niValuesRecordList.get(0);
				NIValueparameterMap = new HashMap<String, Object>();
				if(nIValueRecord.getRefPoId()!=null && !nIValueRecord.getRefPoId().equalsIgnoreCase("")){
					if(nIValueRecord.getRefPoId().contains(tempRefPoId.toString())){
						refPoIdArray = nIValueRecord.getRefPoId().split(",");
						int i=0;
						for(String temStr :refPoIdArray){
							if(!temStr.equals(tempRefPoId.toString())){
								if(i==0){
									refPoId.append(temStr);
								}else{
									refPoId.append(",").append(temStr);
								}
								i++;
							}
						}
						NIValueparameterMap.put("refPoId", refPoId.toString());
					}else{
						NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
					}
					
				}else{
					NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
				}
				
				//end of  deleting existing mapping refPOID value from existing refPOID val
				
				tempNIValue=nIValueRecord.getNiValue().subtract(new BigDecimal(arsPoMappingRecord.getPoColumnVal()));
				if(tempNIValue!=null && tempNIValue.equals(new BigDecimal(0))){
					NIValueparameterMap.put("niValue", null);
				}else{
					NIValueparameterMap.put("niValue", tempNIValue);
				}
				
				NIValueparameterMap.put("niId", nIValueRecord.getNiId());
				//genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNIValueColumnByNIID, NIValues.class, NIValueparameterMap);
			}
			
			// to update NIvalue by adding the NIValue from ARS_PO_MAPPING table in NI_VALUES Table if record exists
			refPoId= new StringBuilder("");
			niValuesRecordList = (ArrayList<NIValues>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNiValauesRecordByFILID,NIValues.class, parameterMap);
			if(niValuesRecordList!=null && niValuesRecordList.size()>0){
				NIValues nIValueRecord = niValuesRecordList.get(0);
				NIValueparameterMap = new HashMap<String, Object>();
				if(nIValueRecord.getRefPoId()!=null && !nIValueRecord.getRefPoId().equalsIgnoreCase("")){
					if(!nIValueRecord.getRefPoId().contains(tempRefPoId.toString())){
						refPoId.append(nIValueRecord.getRefPoId()).append(",").append(tempRefPoId.toString());
						NIValueparameterMap.put("refPoId", refPoId.toString());
					}else{
						NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
					}
					
				}else{
					NIValueparameterMap.put("refPoId", tempRefPoId.toString());
				}
				
				if(nIValueRecord.getNiValue()!=null)
				{
					NIValueparameterMap.put("niValue", new BigDecimal(arsPoMapping.getPoColumnVal()).add(nIValueRecord.getNiValue()));
				}
				else
				{
					NIValueparameterMap.put("niValue", new BigDecimal(arsPoMapping.getPoColumnVal()));	
				}
				NIValueparameterMap.put("niId", nIValueRecord.getNiId());
				//genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNIValueColumnByNIID, NIValues.class, NIValueparameterMap);
				genericDaoImpl.updateByNamedQuery(NamedQueryName.updateArsPoMappingRecord, ArsPoMapping.class, parameterMap);
			}
			else
			{
				List<Object> niIdList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getMaxNIID, NIValues.class);
				for(Object object:niIdList){
					niValues.setNiId(object == null ? 0 : new BigDecimal(object.toString()).intValue()+1);
				}
				if(niValues.getNiId()>0){
					niValues.setRefPoId(tempRefPoId.toString());
					//genericDaoImpl.persist(niValues);
					genericDaoImpl.updateByNamedQuery(NamedQueryName.updateArsPoMappingRecord, ArsPoMapping.class, parameterMap);
				}
			}
		}else{
			// to update NIvalue by adding the NIValue from ARS_PO_MAPPING table in NI_VALUES Table if record exists
			refPoId= new StringBuilder("");
			niValuesRecordList = (ArrayList<NIValues>) (Object) genericDaoImpl
					.findByNamedQuery(NamedQueryName.getNiValauesRecordByFILID,
							NIValues.class, parameterMap);
			
			if(niValuesRecordList!=null && niValuesRecordList.size()>0){
				NIValues nIValueRecord = niValuesRecordList.get(0);
				NIValueparameterMap = new HashMap<String, Object>();
				if(nIValueRecord.getRefPoId()!=null && !nIValueRecord.getRefPoId().equalsIgnoreCase("")){
					if(!nIValueRecord.getRefPoId().contains(tempRefPoId.toString())){
						refPoId.append(nIValueRecord.getRefPoId()).append(",").append(tempRefPoId.toString());
						NIValueparameterMap.put("refPoId", refPoId.toString());
					}else{
						NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
					}
					
				}else{
					
					NIValueparameterMap.put("refPoId", tempRefPoId.toString());
				}
				
				if(nIValueRecord.getNiValue()!=null)
				{
					NIValueparameterMap.put("niValue", new BigDecimal(arsPoMapping.getPoColumnVal()).add(nIValueRecord.getNiValue()));
				}
				else
				{
					NIValueparameterMap.put("niValue", new BigDecimal(arsPoMapping.getPoColumnVal()));	
				}
				NIValueparameterMap.put("niId", nIValueRecord.getNiId());
				//genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNIValueColumnByNIID, NIValues.class, NIValueparameterMap);
				genericDaoImpl.persist(arsPoMapping);
				
			}else{
				// to insert new record in ARS_PO_MAPPING AND NI_VALUES
				
				List<Object> niIdList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getMaxNIID, NIValues.class);
				if(niIdList!=null && niIdList.size()>0){
					Object object =niIdList.get(0);
					niValues.setNiId(object == null ? 0 : new BigDecimal(object.toString()).intValue()+1);
				}
				niValues.setRefPoId(tempRefPoId.toString());
				if(niValues.getNiId()>0){
					//genericDaoImpl.persist(niValues);
					genericDaoImpl.persist(arsPoMapping);
				}
			}
			
		}
		

		LOGGER.info("** End-createArsPoMapping methode NormalizationServiceImpl class");

	}
	
	@SuppressWarnings("unchecked")
	@Override
	public ArsPoMapping getAsRepPOMappingByFilingId(Integer poId,String coulmnName){
		LOGGER.info("** Start-getAsRepPOMappingByFilingId methode NormalizationServiceImpl class");
		
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poId", poId);
		parameterMap.put("poColumnName", coulmnName);
		
		List<ArsPoMapping> ArsPoMappingtList=(ArrayList<ArsPoMapping>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getArsPoMappingRecordsByFILINGID, ArsPoMapping.class, parameterMap);
		ArsPoMapping arsPoMapping =null;
		if(ArsPoMappingtList!=null && ArsPoMappingtList.size()>0){
			arsPoMapping=ArsPoMappingtList.get(0);
			parameterMap.put("filingId", arsPoMapping.getFillingId());
			
			Filings templateId = genericDaoImpl.findByColumn(
					NamedQueryName.getTemplateId, Filings.class, parameterMap);
		
			parameterMap.put("templateId", templateId.getTemplateId());
			parameterMap.put("niItem", arsPoMapping.getNiItem());
			List<NormItemLabels> normItemLabelsList  =(ArrayList<NormItemLabels>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNrmItmLblByTmplteNiItem, NormItemLabels.class, parameterMap);
			if(normItemLabelsList!=null && normItemLabelsList.size()>0){
				NormItemLabels normItemLabels =normItemLabelsList.get(0);
				arsPoMapping.setNormItemSection(normItemLabels.getNilSection());
			}
		}
		LOGGER.info("** End-getAsRepPOMappingByFilingId methode NormalizationServiceImpl class");
		return arsPoMapping;
		
	}
	
	
	
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void  createNIValiues(NIValues niValues) {
		LOGGER.info("** Start-createNIValiues methode NormalizationServiceImpl class");
		List<Object> niIdList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getMaxNIID, NIValues.class);
		
		for(Object object:niIdList){

			
			niValues.setNiId(object == null ? 0 : new BigDecimal(object.toString()).intValue()+1);
		}
		if(niValues.getNiId()>0){
			genericDaoImpl.persist(niValues);
		}
		

		LOGGER.info("** End-createNIValiues methode NormalizationServiceImpl class");

	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutput> getchildNormalizedDataByPoId(Integer poId){
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("refPoId", poId);
		parameterMap.put("statementType", "SUPPL");

		List<ParserOutput> parserOutputList = new ArrayList<ParserOutput>();
		
		List<ParserOutput> objectList = (List<ParserOutput>)(Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNormalizedDataByPOID,ParserOutput.class, parameterMap);
		//ParserOutput parserOutput =null;
		
		String tempNiTem="";
		String[] tempNiTemArray=null;
		Integer niItem=0;
		String trClass="";
		String poSection="";
		for(ParserOutput parserOutput:objectList){
			
			if(parserOutput.getPoAsRepLabel()==null)
			{
				parserOutput.setPoAsRepLabel("");
			}
			
		     String isDuplicate=parserOutput.getIsDuplicate() != null ? parserOutput.getIsDuplicate() : "";
		     if(isDuplicate.equalsIgnoreCase("Y")){
		    	 isDuplicate="trDublicate";	
			  }else{
				  isDuplicate="";	
			  }
		     
		     	tempNiTem=parserOutput.getNiItemSuggstive() != null ? parserOutput.getNiItemSuggstive() : "";
				tempNiTemArray =tempNiTem.split(",");
				parserOutput.setNiItemSuggstive(tempNiTem);
				niItem = parserOutput.getNiItem() != null ? parserOutput.getNiItem() : 0;
				
				if(tempNiTemArray.length >1){
					parserOutput.setIsMultipleNiItems("Y");
					parserOutput.setNilLabel(tempNiTemArray.length + " items selected.");
				}else if(niItem.equals(0) && (tempNiTemArray.length==1 && !tempNiTemArray[0].equalsIgnoreCase(""))){
					parserOutput.setIsMultipleNiItems("Y");
					parserOutput.setNilLabel("1 item selected.");
				}else{
					parserOutput.setIsMultipleNiItems("N");
					parserOutput.setNilLabel(parserOutput.getNilLabel()!= null ? parserOutput.getNilLabel() : "");
				}
				poSection=	parserOutput.getPoSection()!= null ? parserOutput.getPoSection().toString() : "";
			trClass=LiveSpreadUtil.getReviewString(tempNiTem,niItem,poSection);	
			parserOutput.setTrClass(trClass);
			parserOutput.setIsDuplicate(isDuplicate);
			parserOutput.setEncryptedFilingId(CipherUtils.encrypt(parserOutput.getFillingId().toString()));
			parserOutputList.add(parserOutput);
		}
		
		return parserOutputList;
	}
	
	@Override
 public List<Integer> selectSupplPoIds(Integer fillingId){
	 Map<String, Object> parameterMap = new HashMap<String, Object>();
	 List<Integer> supplPoiIdList = new ArrayList<Integer>();
	 try{
		 parameterMap.put("fillingId", fillingId);
		 
			List<Object> objectList = genericDaoImpl
					.findByNativeNamedQuery(
							NamedNativeQueryName.getSupplParserOutputRefIDs,
							ParserOutput.class, parameterMap);
			for(Object object:objectList){
				
				supplPoiIdList.add(object!=null ? Integer.parseInt(object.toString()) :0);
			}
		 
	 }catch(Exception e){
		 e.printStackTrace();
	 }
	 return supplPoiIdList;
 }

	public boolean f_auditNewRecordInAuditTable(NormalizeFormData normalizeFormData,Integer poId){
		LOGGER.info("** start- f_auditNewRecordInAuditTable methode");
	boolean flag=false;
	
	try {
		
			ParserOutputAudit parserOutputAudit=new ParserOutputAudit();
			parserOutputAudit.setIsExtraction("N");
			parserOutputAudit.setCreatedBy(normalizeFormData.getCreatedBy());
			parserOutputAudit.setPoaDocumentStatusOld(normalizeFormData.getDocumentStatus());
			parserOutputAudit.setPoaFilingId(normalizeFormData.getFillingId());
		    parserOutputAudit.setPoaTransactionId(normalizeFormData.getTransactionId());
		    parserOutputAudit.setPoaCrudStatus("U");
		    parserOutputAudit.setPoaPoId(poId);
		    // if case_status is ASSIGN_TO_CHECKER =checker  otherwise Maker
			parserOutputAudit.setUserRole(normalizeFormData.getCaseStatus());
		
	} catch (Exception e) {
		LOGGER.error("Error in f_auditNewRecordInAuditTable methode:",e);
	}
	
	LOGGER.info("** end- f_auditNewRecordInAuditTable methode");
	return flag;
	}

	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#selectBreakupsPoIds(java.lang.Integer)
	 */
	@Override
	public List<Integer> selectBreakupsPoIds(Integer fillingId) 
	{
		 Map<String, Object> parameterMap = new HashMap<String, Object>();
		 List<Integer> breakupPoiIdList = new ArrayList<Integer>();
		 try{
			 parameterMap.put("fillingId", fillingId);
				List<Object> objectList = genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getBreakupsParserOutputRefIDs, ParserOutput.class, parameterMap);
				for(Object object:objectList){
					breakupPoiIdList.add(object!=null ? Integer.parseInt(object.toString()) :0);
				}
			 
		 }catch(Exception e){
			 e.printStackTrace();
		 }
		 return breakupPoiIdList;
	 
	}
	
 
	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutputCommand> getArsPoMappingListByFilingId(List<ParserOutput> parserOutPutList){
		
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		List<ArsPoMapping> arsPoMappingRecordList=null;
		List<ParserOutput> finalParserOutPutList=new ArrayList<ParserOutput>();;
		List<ArsPoMapping> arsPoMappingSubList=null;
		ParserOutputCommand parserOutputCommand =null;
		List<ParserOutputCommand> parserOutPutCommandList=new ArrayList<ParserOutputCommand>();
		List<Integer> poIdList = null;
		List<String> isCoordinateExists = null;
		Map<Integer, POCordHighlightDetails> seletedPoCordDetailsMap = null;
		Method  method = null;
		Object objectValue = null;
		Class<?> parserOutputClass =null;
		Class<?> poCordHighlightDetailsClass =null;
		try {
			parserOutputClass = Class.forName("com.livespread.domain.ParserOutput");
			poCordHighlightDetailsClass = Class.forName("com.livespread.domain.POCordHighlightDetails");
		} catch (ClassNotFoundException e1) {
			e1.printStackTrace();
		}

			
		try{
			parameterMap.put("fillingId", parserOutPutList.get(0).getFillingId());

			 arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getArsPoMappingdByFilingId,ArsPoMapping.class, parameterMap);

			 
			 if(!CollectionUtils.isEmpty(parserOutPutList))
				{
					poIdList = new ArrayList<>();
					seletedPoCordDetailsMap = new HashMap<>();
					for (ParserOutput selectedParserOutput : parserOutPutList) 
					{
						poIdList.add(selectedParserOutput.getPoId());
					}
					seletedPoCordDetailsMap = poCordHighlightDetailsService.getCoordinateDetailsMap(poIdList);
				}
			 
			 for(ParserOutput parserOutput : parserOutPutList){
					 parserOutputCommand=new ParserOutputCommand();
					 BeanUtils.copyProperties(parserOutput, parserOutputCommand);
				
					 Map<Integer, String> isPoAsRepValueMapped=new HashMap<Integer,String>();
					 Map<Integer, String> isPoAsRepValueMappedByPeriod=new HashMap<Integer,String>();
					 /**Here set default values to "N"**/
					 for(int i=1;i<=20;i++){
						 isPoAsRepValueMapped.put(i,"N");
						 isPoAsRepValueMappedByPeriod.put(i,"N");
						 parserOutputCommand.setIsPoAsRepValueMapped(isPoAsRepValueMapped);
						 parserOutputCommand.setIsPoAsRepValueMappedByPeriod(isPoAsRepValueMappedByPeriod);
					 }
					 
					 if(!CollectionUtils.isEmpty(arsPoMappingRecordList)){
					 arsPoMappingSubList =new ArrayList<ArsPoMapping>();
					 
					 for(ArsPoMapping arsPoMapping : arsPoMappingRecordList){
							
							if(arsPoMapping.getPoId().equals(parserOutput.getPoId())){
								for(int i=1;i<=20;i++)
								{
								 if(arsPoMapping.getPoColumnName().contains("val"+i))
								  {
									 if(arsPoMapping.getArsId().intValue() == 0 )
									 {
									 isPoAsRepValueMappedByPeriod.put(i,"Y");
									 parserOutputCommand.setIsPoAsRepValueMappedByPeriod(isPoAsRepValueMappedByPeriod);	 
									 }
									 else
									 {
									isPoAsRepValueMapped.put(i,"Y");
									parserOutputCommand.setIsPoAsRepValueMapped(isPoAsRepValueMapped);	 
									 }
								 }
								}//end column counter loop
							}//end arsPoMapping if condition
						}//end arsPoMapping for loop
					 }//end empty arsPoMappingRecordList if 
					 Map<Integer,String> asRepValMap=new LinkedHashMap<Integer,String>();
					 POCordHighlightDetails seletedPoCordDetails = null;
					 isCoordinateExists = new ArrayList<>();
						for (int i = 1 ; i<= 20; i++){
							method = parserOutputClass.getDeclaredMethod("getPoAsRepVal"+i);
							objectValue = method.invoke (parserOutput);
							if(objectValue!=null && !objectValue.toString().isEmpty())
							{
								objectValue.toString().trim();
								asRepValMap.put(i, objectValue.toString().trim());
							}
							
							seletedPoCordDetails = seletedPoCordDetailsMap.get(parserOutput.getPoId());
							if(seletedPoCordDetails!=null)
							{
								method = poCordHighlightDetailsClass.getDeclaredMethod("getCordDetailsVAL"+i);
								objectValue = method.invoke (seletedPoCordDetails);
								if(objectValue!=null && objectValue.toString().trim()!="" && !objectValue.toString().trim().contains("0,0,0,0"))
								{
									isCoordinateExists.add("Y");
								}
								else
								{
									isCoordinateExists.add("N");
								}
							}
							
						}
						if(!CollectionUtils.isEmpty(isCoordinateExists))
						{
							parserOutputCommand.setIsCoordinateExists(isCoordinateExists);
						}
						parserOutputCommand.setPoAsRepVal(asRepValMap);	
						parserOutputCommand.setUploadId(parserOutput.getUploadId() == null ? 0 : parserOutput.getUploadId());
					 if(!CollectionUtils.isEmpty(arsPoMappingSubList)){
						 parserOutput.setArsPoMappingList(arsPoMappingSubList);
					 }
					 finalParserOutPutList.add(parserOutput);
					 parserOutPutCommandList.add(parserOutputCommand);
				 }
			
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return parserOutPutCommandList;
	}

@SuppressWarnings("unchecked")
@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public List<NotesCheckListCommand> getNotesCheckList(Integer filingId) throws DataAccessException {
	LOGGER.info("**start--getNotesCheckListe function");
	Map<String, Object> parameters = new HashMap<String, Object>();
	parameters.put("fillingId", filingId);
	List<NotesCheckList> notesCheckListRecords = new ArrayList<NotesCheckList>();
	List<NotesCheckListCommand> notesChecksCommandList = new ArrayList<NotesCheckListCommand>();
	NotesCheckListCommand notesCheckListCommand = null;
	try{
		
		notesCheckListRecords= (ArrayList<NotesCheckList>)(Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNotesCheckListRecordsByFillingId, NotesCheckList.class,parameters);
		 if(!CollectionUtils.isEmpty(notesCheckListRecords)){
			 for(NotesCheckList notesCheckList:notesCheckListRecords){
				 notesCheckListCommand= new NotesCheckListCommand();
				 BeanUtils.copyProperties(notesCheckList, notesCheckListCommand);
				 notesChecksCommandList.add(notesCheckListCommand);
				 
			 }
			 
		 }
		 
	}catch(Exception e){
		e.printStackTrace();
		LOGGER.error(e.getMessage());
	}
	
	LOGGER.info("**end--getNotesCheckListe function");
	return notesChecksCommandList;
}

@SuppressWarnings("unchecked")
@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public boolean deleteArsPoMapping(Integer poId, String columnName){
	LOGGER.info("** Start-deleteArsPoMapping methode NormalizationServiceImpl class");
	List<NIValues> niValuesRecordList=null;
	Map<String, Object> parameterMap = new HashMap<String, Object>();
	Map<String, Object> NIValueparameterMap = new HashMap<String, Object>();
	HashMap<String, Object> existingArsNIValueparameterMap = new HashMap<String, Object>();
	try{
		StringBuilder tempRefPoId= new StringBuilder("");
		StringBuilder refPoId=new StringBuilder("");
		BigDecimal tempNIValue= new BigDecimal(0);
		String orignalColumnName="";
		String[] refPoIdArray = null;
		//To prepare refPOID for this mapping 
				if(columnName!=null && columnName.contains("child")){
					orignalColumnName=columnName.substring(5);
				}else{
					orignalColumnName=columnName!=null?columnName:"";
				}
				tempRefPoId.append(poId).append("-PO_").append(orignalColumnName.toUpperCase());
				//end of preparing refPOID for this mapping 
				
		parameterMap.put("poId", poId);
		parameterMap.put("poColumnName", orignalColumnName);
		List<ArsPoMapping> arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getArsPoMappingRecordsByFILINGID,
						ArsPoMapping.class, parameterMap);
		
		ArsPoMapping arsPoMappingRecord= new ArsPoMapping();
		if(arsPoMappingRecordList!=null && arsPoMappingRecordList.size()>0){
			arsPoMappingRecord=arsPoMappingRecordList.get(0);
		}
		if(arsPoMappingRecord!=null && arsPoMappingRecord.getPoId()!=null){
			
			existingArsNIValueparameterMap.put("fillingId", arsPoMappingRecord.getFillingId());
			existingArsNIValueparameterMap.put("arsId", arsPoMappingRecord.getArsId());
			existingArsNIValueparameterMap.put("niItem", arsPoMappingRecord.getNiItem());
			niValuesRecordList = (ArrayList<NIValues>) (Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getNiValauesRecordByFILID,NIValues.class, existingArsNIValueparameterMap);
			
			if(niValuesRecordList!=null && niValuesRecordList.size()>0){
				NIValues nIValueRecord = niValuesRecordList.get(0);
				if(nIValueRecord.getRefPoId()!=null && !nIValueRecord.getRefPoId().equalsIgnoreCase("")){
					if(nIValueRecord.getRefPoId().contains(tempRefPoId.toString())){
						refPoIdArray = nIValueRecord.getRefPoId().split(",");
						int i=0;
						for(String temStr :refPoIdArray){
							if(!temStr.equals(tempRefPoId.toString())){
								if(i==0){
									refPoId.append(temStr);
								}else{
									refPoId.append(",").append(temStr);
								}
								i++;
							}
						}
						NIValueparameterMap.put("refPoId", refPoId.toString());
					}else{
						NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
					}
					
				}else{
					NIValueparameterMap.put("refPoId", nIValueRecord.getRefPoId());
				}
				tempNIValue=nIValueRecord.getNiValue().subtract(new BigDecimal(arsPoMappingRecord.getPoColumnVal()));
				if(tempNIValue!=null && tempNIValue.equals(new BigDecimal(0))){
					NIValueparameterMap.put("niValue", null);
				}else{
					NIValueparameterMap.put("niValue", tempNIValue);
				}
				
				NIValueparameterMap.put("niId", nIValueRecord.getNiId());
				genericDaoImpl.updateByNamedQuery(NamedQueryName.updateNIValueColumnByNIID, NIValues.class, NIValueparameterMap);
			}
			genericDaoImpl.remove(arsPoMappingRecord);
		}
	}catch(Exception e){
		e.printStackTrace();
		return false;
	}
	
	
	LOGGER.info("** End-deleteArsPoMapping methode NormalizationServiceImpl class");
	return true;
}

@Override
@SuppressWarnings("unchecked")
public List<ArsPoMapping>  getArsPoMappingdByFilingId(Integer fillingId){
	
	 Map<String, Object> parameterMap = new HashMap<String, Object>();
	List<ArsPoMapping> arsPoMappingRecordList=null;
	try{
		
		parameterMap.put("fillingId", fillingId);

		 arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
						.findByNamedQuery(NamedQueryName.getArsPoMappingdByFilingId,
								ArsPoMapping.class, parameterMap);
		 
		
				 
	}catch(Exception e){
		e.printStackTrace();
	}
	
	
	return arsPoMappingRecordList;
}

/* (non-Javadoc)
 * @see com.livespread.service.NormalizationService#getchildNormalizedDataByNiId(java.lang.Integer)
 */

@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public List<NormalizationBreakupData> getchildNormalizedDataByNiId(Integer niId) 
{
	String refPoId = null;
	List<NormalizationBreakupData> normalizationBreakupDataList = null;
	NormalizationBreakupData normalizationBreakupData = null;
	Map<String, Object> parameterMap = new HashMap<String, Object>();
	
	parameterMap.put("niId", niId);
	List<Object> niIdList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getRefPoIds, NIValues.class,parameterMap);
	if(niIdList!=null && !niIdList.isEmpty())
	{
		refPoId = (String) niIdList.get(0);
	}
	String[] refPoIdDataArray = null;
	if(refPoId!=null && !refPoId.isEmpty())
	{
		refPoIdDataArray = refPoId.split(",");	
	}
	
	if(refPoIdDataArray!=null && refPoIdDataArray.length>0)
	{
		normalizationBreakupDataList = new ArrayList<NormalizationBreakupData>();
		for (String selectedDataString : refPoIdDataArray) 
		{
			String[] poIdArdDetailsDataAray = selectedDataString.split("-");
			if(poIdArdDetailsDataAray!=null && poIdArdDetailsDataAray.length==2)
			{
				Integer selectedPoId = Integer.parseInt(poIdArdDetailsDataAray[0].toString());
				String columnName = poIdArdDetailsDataAray[1].toString();
				String coordinateColumn = columnName.replace("PO", "CORD_DETAILS");
				columnName = "po."+columnName;
				coordinateColumn = "POCH."+coordinateColumn;
				normalizationBreakupData = normalizationViewDAO.normalizationBreakupDetails(selectedPoId,columnName,coordinateColumn);
				if(normalizationBreakupData!=null)
				{
					if(normalizationBreakupData.getIsCoordinateExists().equalsIgnoreCase("Y"))
					{
						String column =columnName.replace("po.PO_VAL", "val");
						normalizationBreakupData.setColumn(column);;
					}
					normalizationBreakupDataList.add(normalizationBreakupData);
				}
			}
		}
	}
	return normalizationBreakupDataList;
}


@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.RAGE_TX_MANAGER)
public Integer generatePkForProcessQueue()
{
	Map<String, Object> parameterMap = new HashMap<String, Object>();
	parameterMap.put("sequenceName", "RD_SEQUENCE");
	Integer id = null;
	synchronized (parameterMap) {
		id = genericDaoImpl.updateByNamedQuery(NamedQueryName.updateRequestQueueSequencer, RageSequenceMaster.class, parameterMap);	
	}
	return id;
}

@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public boolean updateNotes(Integer decryptedWqEid, String Notestext) {
CompanyNotes cmpyNotes=null;
	try{
			if (decryptedWqEid != null) {
				cmpyNotes = new CompanyNotes();
				cmpyNotes.setWqEid(decryptedWqEid);
				cmpyNotes.setNotesDescription(Notestext);
			     genericDaoImpl.merge(cmpyNotes);
			}else{
				return false;	
			}
	}
	catch(Exception e){
			e.printStackTrace();
			LOGGER.error("exception Notes Update"+ e);	
		}	
	return true;
}

@Override
public String findNoteTextByWqEid(Integer decryptedWqEid) {
	String noteValue = null;
	if(decryptedWqEid!=null){
		LOGGER.info("start find  NoteTextBy WqEid function");
				Map<String, Object> parameters = new HashMap<String, Object>();
				parameters.put("decryptedWqEid", decryptedWqEid);
				CompanyNotes noteTexts = genericDaoImpl.findByColumn(
						NamedQueryName.getCompanyNotesByWqEid, CompanyNotes.class, parameters);
				if(noteTexts!=null){
				noteValue = noteTexts.getNotesDescription();
				}
			}
	return noteValue;
}


private ParserOutputAuditTrail getOriginalPORecordToPOATRecord(NormalizeFormData normalizeFormData,Integer poId){
	ParserOutputAuditTrail parserOutputAuditTrail = new ParserOutputAuditTrail();
	try{
		
		ParserOutput parserOutputOld=qaMessageChecklistService.getRecordUsingPOID(poId);
		parserOutputAuditTrail.setFilingId(parserOutputOld.getFillingId());
		parserOutputAuditTrail.setPoDocOldStatus(normalizeFormData.getDocumentStatus());
		parserOutputAuditTrail.setUserRole(normalizeFormData.getCaseStatus());
		parserOutputAuditTrail.setCreatedBy(normalizeFormData.getCreatedBy());
		parserOutputAuditTrail.setCreatedDate(new Date());
		parserOutputAuditTrail.setPoIndexOrder(parserOutputOld.getPoIndexOrder()!=null?parserOutputOld.getPoIndexOrder():0);
		parserOutputAuditTrail.setArsLabel(parserOutputOld.getPoAsRepLabel()!=null?parserOutputOld.getPoAsRepLabel():"");
		parserOutputAuditTrail.setBreakup(parserOutputOld.getPoBreakup()!=null?parserOutputOld.getPoBreakup():"");
		parserOutputAuditTrail.setPoNote(parserOutputOld.getNote()!=null?parserOutputOld.getNote():"");
		parserOutputAuditTrail.setNiItem(parserOutputOld.getNiItem()!=null?parserOutputOld.getNiItem():0);
		parserOutputAuditTrail.setNilLabel(parserOutputOld.getNilLabel()!=null?parserOutputOld.getNilLabel():"");
		parserOutputAuditTrail.setIsExtraction("N");
		parserOutputAuditTrail.setPoaTransactionId(normalizeFormData.getTransactionId());
		parserOutputAuditTrail.setPoSubSection(parserOutputOld.getPoSubSection()!=null?parserOutputOld.getPoSubSection():"");
		parserOutputAuditTrail.setPoId(poId);
		parserOutputAuditTrail.setSection(parserOutputOld.getPoSection());
		parserOutputAuditTrail.setPageNumber(parserOutputOld.getPageNo());
		parserOutputAuditTrail.setNiItemSuggestive(parserOutputOld.getNiItemSuggstive());
		
		
		String propName="poVal";
		String keyVal="getPoAsRepVal";
		Field targetField=null;
		boolean accessible=false;
		
		Method sourceField = null;
		
		for(int i=1;i<=20;i++){
			propName="poVal";
			keyVal="getPoAsRepVal";
			propName=propName+i;
			keyVal=keyVal+i;
			targetField = ParserOutputAuditTrail.class.getDeclaredField(propName);
			sourceField = ParserOutput.class.getMethod(keyVal);
			accessible = targetField.isAccessible();
			targetField.setAccessible(true);
			targetField.set(parserOutputAuditTrail,  sourceField.invoke(parserOutputOld)!=null ? sourceField.invoke(parserOutputOld).toString() :sourceField.invoke(parserOutputOld) );
		
			targetField.setAccessible(accessible);
		
		}
		
		LOGGER.info("** End- getOriginalPORecordToPOATRecord methode");
		
	}catch (Exception e) {
		e.printStackTrace();
	LOGGER.info("** Error in getOriginalPORecordToPOATRecord methode methode:",e);
	return null;
	}
	return parserOutputAuditTrail;
}

private ParserOutputAuditTrail getOriginalPORecordToPOATRecord(NormalizeFormData normalizeFormData,ParserOutput parserOutput){
	ParserOutputAuditTrail parserOutputAuditTrail = new ParserOutputAuditTrail();
	try{
		
		
		parserOutputAuditTrail.setFilingId(parserOutput.getFillingId());
		parserOutputAuditTrail.setPoDocOldStatus(normalizeFormData.getDocumentStatus());
	    parserOutputAuditTrail.setUserRole(normalizeFormData.getCaseStatus());
		parserOutputAuditTrail.setCreatedBy(normalizeFormData.getCreatedBy());
		parserOutputAuditTrail.setCreatedDate(new Date());
		parserOutputAuditTrail.setPoIndexOrder(parserOutput.getPoIndexOrder()!=null?parserOutput.getPoIndexOrder():0);
		parserOutputAuditTrail.setArsLabel(parserOutput.getPoAsRepLabel()!=null?parserOutput.getPoAsRepLabel():"");
		parserOutputAuditTrail.setBreakup(parserOutput.getPoBreakup()!=null?parserOutput.getPoBreakup():"");
		parserOutputAuditTrail.setPoNote(parserOutput.getNote()!=null?parserOutput.getNote():"");
		parserOutputAuditTrail.setNiItem(parserOutput.getNiItem()!=null?parserOutput.getNiItem():0);
		parserOutputAuditTrail.setNilLabel(parserOutput.getNilLabel()!=null?parserOutput.getNilLabel():"");
		
		parserOutputAuditTrail.setIsExtraction("N");
		parserOutputAuditTrail.setPoaTransactionId(normalizeFormData.getTransactionId());
		parserOutputAuditTrail.setPoSubSection(parserOutput.getPoSubSection()!=null?parserOutput.getPoSubSection():"");
		parserOutputAuditTrail.setPoId(parserOutput.getPoId());
		parserOutputAuditTrail.setSection(parserOutput.getPoSection());
		parserOutputAuditTrail.setNiItemSuggestive(parserOutput.getNiItemSuggstive());
		
		
		
		String propName="poVal";
		String keyVal="getPoAsRepVal";
		Field targetField=null;
		boolean accessible=false;
		
		Method sourceField = null;
		
		for(int i=1;i<=20;i++){
			propName="poVal";
			keyVal="getPoAsRepVal";
			propName=propName+i;
			keyVal=keyVal+i;
			targetField = ParserOutputAuditTrail.class.getDeclaredField(propName);
			sourceField = ParserOutput.class.getMethod(keyVal);
			accessible = targetField.isAccessible();
			targetField.setAccessible(true);
			targetField.set(parserOutputAuditTrail,  sourceField.invoke(parserOutput)!=null? sourceField.invoke(parserOutput).toString() :sourceField.invoke(parserOutput));
		
			targetField.setAccessible(accessible);
		
		}
		LOGGER.info("** End- getOriginalPORecordToPOATRecord method");
		
	}catch (Exception e) {
		e.printStackTrace();
	LOGGER.info("** Error in getOriginalPORecordToPOATRecord methode methode:",e);
	return null;
	}
	return parserOutputAuditTrail;
}


@SuppressWarnings("unchecked")
@Override
public List<ScaleCommand> getScaleList(){
	LOGGER.info("start getScaleList method >> ");
	List<ScaleCommand> scaleCommandList = new ArrayList<ScaleCommand>();
	ScaleCommand scaleCommand =null;
	try{
		List<Scale> scaleList = (ArrayList<Scale>) (Object) genericDaoImpl
					.findByNamedQuery(NamedQueryName.getScaleList,Scale.class);
		
		if(!CollectionUtils.isEmpty(scaleList)){
			for(Scale scale : scaleList){
				scaleCommand= new ScaleCommand();
				BeanUtils.copyProperties(scale, scaleCommand);
				scaleCommandList.add(scaleCommand);
			}
			
		}
		return scaleCommandList;
	}catch(Exception e){
		LOGGER.error("** Error in getScaleList methode methode:",e);
		 
	}
	
	
	 LOGGER.info("** End- getScaleList method <<");
	 return null;

}


@SuppressWarnings("unchecked")
@Override
public List<ScaleChangeSignPoMappingCommand> getScaleChangeSignPoMappingList(Integer filingId){
	LOGGER.info("start getScaleChangeSignPoMappingList method >> ");
	List<ScaleChangeSignPoMappingCommand> scaleChangeSignPoMappingCommandList = new ArrayList<ScaleChangeSignPoMappingCommand>();
	ScaleChangeSignPoMappingCommand scaleChangeSignPoMappingCommand = null;
	try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId",filingId);
		
		List<ScaleChangeSignPoMapping> ScaleChangeSignPoMappingList = (ArrayList<ScaleChangeSignPoMapping>) (Object) genericDaoImpl
					.findByNamedQuery(NamedQueryName.getScaleChangeSignPoMappingListbyFilingId,
							ScaleChangeSignPoMapping.class,parameterMap);
		
		if(!CollectionUtils.isEmpty(ScaleChangeSignPoMappingList)){
			
			for(ScaleChangeSignPoMapping scaleChangeSignPoMapping : ScaleChangeSignPoMappingList){
				scaleChangeSignPoMappingCommand= new ScaleChangeSignPoMappingCommand();
				BeanUtils.copyProperties(scaleChangeSignPoMapping, scaleChangeSignPoMappingCommand);
				scaleChangeSignPoMappingCommandList.add(scaleChangeSignPoMappingCommand);
			}
			BeanUtils.copyProperties(ScaleChangeSignPoMappingList, scaleChangeSignPoMappingCommandList);
		}
		return scaleChangeSignPoMappingCommandList;
	}catch(Exception e){
		LOGGER.error("** Error in getScaleChangeSignPoMappingList methode methode:",e);
		 
	}
	
	
	 LOGGER.info("** End- getScaleChangeSignPoMappingList method <<");
	 return null;
}

@SuppressWarnings("unchecked")
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public boolean createOrUpdateScaleChangePoMapping(ScaleChangeSignPoMappingCommand scaleChangeSignPoMappingCommand) {
	LOGGER.info("start createOrUpdateScaleChangeSignPoMapping method >> ");
	try{
		ParserOutput parserOutput=qaMessageChecklistService.getRecordUsingPOID(scaleChangeSignPoMappingCommand.getPoId());
		ParserOutputAuditTrail parserOutputAuditTrailOriginal = new ParserOutputAuditTrail();
		parserOutputAuditTrailOriginal=getOriginalPORecordToPOATRecord(scaleChangeSignPoMappingCommand,parserOutput);
		genericDaoImpl.persist(parserOutputAuditTrailOriginal);
		ParserOutputAuditTrail parserOutputAuditTrailUpdated = new ParserOutputAuditTrail();
		parserOutputAuditTrailUpdated=getOriginalPORecordToPOATRecord(scaleChangeSignPoMappingCommand,parserOutput);
		parserOutputAuditTrailUpdated.setPoCrudStatus("U");
		
		if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val1")){
			parserOutput.setPoAsRepVal1(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			parserOutputAuditTrailUpdated.setCategory("PO_VAL1");
			parserOutputAuditTrailUpdated.setPoVal1(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val2")){
			 parserOutput.setPoAsRepVal2(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL2");
			 parserOutputAuditTrailUpdated.setPoVal2(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val3")){
			 parserOutput.setPoAsRepVal3(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL3");
			 parserOutputAuditTrailUpdated.setPoVal3(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val4")){
			 parserOutput.setPoAsRepVal4(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL4");
			 parserOutputAuditTrailUpdated.setPoVal4(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val5")){
			 parserOutput.setPoAsRepVal5(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL5");
			 parserOutputAuditTrailUpdated.setPoVal5(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val6")){
			 parserOutput.setPoAsRepVal6(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL6");
			 parserOutputAuditTrailUpdated.setPoVal6(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val7")){
			 parserOutput.setPoAsRepVal7(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL7");
			 parserOutputAuditTrailUpdated.setPoVal7(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val8")){
			 parserOutput.setPoAsRepVal8(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL8");
			 parserOutputAuditTrailUpdated.setPoVal8(scaleChangeSignPoMappingCommand.getChangedColumnVal());
		 }
		
		genericDaoImpl.persist(parserOutput);
		genericDaoImpl.persist(parserOutputAuditTrailUpdated);
		
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poId",scaleChangeSignPoMappingCommand.getPoId());
		parameterMap.put("poColumnName",scaleChangeSignPoMappingCommand.getPoColumnName());
		
		List<ScaleChangeSignPoMapping> ScaleChangeSignPoMappingList = (ArrayList<ScaleChangeSignPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getScaleChangeSignPoMappingListbypoIdandColumnName,
						ScaleChangeSignPoMapping.class,parameterMap);
		ScaleChangeSignPoMapping scaleChangeSignPoMapping = new ScaleChangeSignPoMapping();
		if(!CollectionUtils.isEmpty(ScaleChangeSignPoMappingList)){
			scaleChangeSignPoMapping =ScaleChangeSignPoMappingList.get(0);
			scaleChangeSignPoMapping.setScaleVal(scaleChangeSignPoMappingCommand.getScaleVal());
			
		}else{
			BeanUtils.copyProperties(scaleChangeSignPoMappingCommand, scaleChangeSignPoMapping);
			scaleChangeSignPoMapping.setScaleChangeSignPoMappingId(null);
			
		}
		List<ArsPoMapping> arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getArsPoMappingRecordsByFILINGID,
						ArsPoMapping.class, parameterMap);
		ArsPoMapping arsPoMappingRecord= new ArsPoMapping();
		
		if(arsPoMappingRecordList!=null && arsPoMappingRecordList.size()>0){
			arsPoMappingRecord=arsPoMappingRecordList.get(0);
			arsPoMappingRecord.setPoColumnVal(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			genericDaoImpl.persist(arsPoMappingRecord);
		}
		
		genericDaoImpl.persist(scaleChangeSignPoMapping);
		
		
	}catch(Exception e){
		LOGGER.error("** Error in createOrUpdateScaleChangeSignPoMapping methode methode:",e);
		 
	}
	LOGGER.info("** End- createOrUpdateScaleChangeSignPoMapping method <<");
	return true;
}


@SuppressWarnings("unchecked")
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public boolean createOrUpdateSignChangePoMapping(ScaleChangeSignPoMappingCommand scaleChangeSignPoMappingCommand) {
	LOGGER.info("start createOrUpdateSignChangePoMapping method >> ");
	try{
		ParserOutput parserOutput=qaMessageChecklistService.getRecordUsingPOID(scaleChangeSignPoMappingCommand.getPoId());
		ParserOutputAuditTrail parserOutputAuditTrailOriginal = new ParserOutputAuditTrail();
		parserOutputAuditTrailOriginal=getOriginalPORecordToPOATRecord(scaleChangeSignPoMappingCommand,parserOutput);
		genericDaoImpl.persist(parserOutputAuditTrailOriginal);
		ParserOutputAuditTrail parserOutputAuditTrailUpdated = new ParserOutputAuditTrail();
		parserOutputAuditTrailUpdated=getOriginalPORecordToPOATRecord(scaleChangeSignPoMappingCommand,parserOutput);
		parserOutputAuditTrailUpdated.setPoCrudStatus("U");
		
		
		if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val1")){
			parserOutput.setPoAsRepVal1(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			parserOutputAuditTrailUpdated.setCategory("PO_VAL1");
			parserOutputAuditTrailUpdated.setPoVal1(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val2")){
			 parserOutput.setPoAsRepVal2(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL2");
			 parserOutputAuditTrailUpdated.setPoVal2(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val3")){
			 parserOutput.setPoAsRepVal3(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL3");
			 parserOutputAuditTrailUpdated.setPoVal3(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val4")){
			 parserOutput.setPoAsRepVal4(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL4");
			 parserOutputAuditTrailUpdated.setPoVal4(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val5")){
			 parserOutput.setPoAsRepVal5(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL5");
			 parserOutputAuditTrailUpdated.setPoVal5(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val6")){
			 parserOutput.setPoAsRepVal6(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL6");
			 parserOutputAuditTrailUpdated.setPoVal6(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val7")){
			 parserOutput.setPoAsRepVal7(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL7");
			 parserOutputAuditTrailUpdated.setPoVal7(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 
		 }else if(scaleChangeSignPoMappingCommand.getPoColumnName().contains("val8")){
			 parserOutput.setPoAsRepVal8(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			 parserOutputAuditTrailUpdated.setCategory("PO_VAL8");
			 parserOutputAuditTrailUpdated.setPoVal8(scaleChangeSignPoMappingCommand.getChangedColumnVal());
		 }
		genericDaoImpl.persist(parserOutput);
		genericDaoImpl.persist(parserOutputAuditTrailUpdated);
		
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poId",scaleChangeSignPoMappingCommand.getPoId());
		parameterMap.put("poColumnName",scaleChangeSignPoMappingCommand.getPoColumnName());
		
		List<ScaleChangeSignPoMapping> ScaleChangeSignPoMappingList = (ArrayList<ScaleChangeSignPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getScaleChangeSignPoMappingListbypoIdandColumnName,
						ScaleChangeSignPoMapping.class,parameterMap);
		ScaleChangeSignPoMapping scaleChangeSignPoMapping = new ScaleChangeSignPoMapping();
		if(!CollectionUtils.isEmpty(ScaleChangeSignPoMappingList)){
			scaleChangeSignPoMapping =ScaleChangeSignPoMappingList.get(0);
			scaleChangeSignPoMapping.setSignVal(scaleChangeSignPoMappingCommand.getSignVal());
			
		}else{
			BeanUtils.copyProperties(scaleChangeSignPoMappingCommand, scaleChangeSignPoMapping);
			scaleChangeSignPoMapping.setScaleChangeSignPoMappingId(null);
			
		}
		List<ArsPoMapping> arsPoMappingRecordList = (ArrayList<ArsPoMapping>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getArsPoMappingRecordsByFILINGID,
						ArsPoMapping.class, parameterMap);
		ArsPoMapping arsPoMappingRecord= new ArsPoMapping();
		
		if(arsPoMappingRecordList!=null && arsPoMappingRecordList.size()>0){
			arsPoMappingRecord=arsPoMappingRecordList.get(0);
			arsPoMappingRecord.setPoColumnVal(scaleChangeSignPoMappingCommand.getChangedColumnVal());
			genericDaoImpl.persist(arsPoMappingRecord);
		}
		
		genericDaoImpl.persist(scaleChangeSignPoMapping);	
		
		
		
	}catch(Exception e){
		LOGGER.error("** Error in createOrUpdateSignChangePoMapping methode methode:",e);
		 
	}
	LOGGER.info("** End- createOrUpdateSignChangePoMapping method <<");
	return true;
}




@SuppressWarnings("unchecked")
@Override
public ScaleChangeSignPoMappingCommand getScaleChangeSignPoMappingListByPoId(Integer poId,String ColName){
	LOGGER.info("start getScaleChangeSignPoMappingList method >> ");
	List<ScaleChangeSignPoMappingCommand> scaleChangeSignPoMappingCommandList = new ArrayList<ScaleChangeSignPoMappingCommand>();
	ScaleChangeSignPoMappingCommand scaleChangeSignPoMappingCommand = null;
	try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("poId",poId);
		parameterMap.put("poColumnName",ColName);
		
		List<ScaleChangeSignPoMapping> ScaleChangeSignPoMappingList = (ArrayList<ScaleChangeSignPoMapping>) (Object) genericDaoImpl
					.findByNamedQuery(NamedQueryName.getScaleChangeSignPoMappingListbypoIdandColumnName,
							ScaleChangeSignPoMapping.class,parameterMap);
		
		if(!CollectionUtils.isEmpty(ScaleChangeSignPoMappingList)){
			
			for(ScaleChangeSignPoMapping scaleChangeSignPoMapping : ScaleChangeSignPoMappingList){
				scaleChangeSignPoMappingCommand= new ScaleChangeSignPoMappingCommand();
				BeanUtils.copyProperties(scaleChangeSignPoMapping, scaleChangeSignPoMappingCommand);
				scaleChangeSignPoMappingCommandList.add(scaleChangeSignPoMappingCommand);
			}
			BeanUtils.copyProperties(ScaleChangeSignPoMappingList, scaleChangeSignPoMappingCommandList);
			return scaleChangeSignPoMappingCommandList.get(0);
		}
		
	}catch(Exception e){
		LOGGER.error("** Error in getScaleChangeSignPoMappingList methode methode:",e);
		 
	}
	
	
	 LOGGER.info("** End- getScaleChangeSignPoMappingList method <<");
	 return null;
}


private ParserOutputAuditTrail getOriginalPORecordToPOATRecord(ScaleChangeSignPoMappingCommand scaleChangeSignPoMappingCommand,ParserOutput parserOutput){
	ParserOutputAuditTrail parserOutputAuditTrail = new ParserOutputAuditTrail();
	try{
		
		
		parserOutputAuditTrail.setFilingId(parserOutput.getFillingId());
		parserOutputAuditTrail.setPoDocOldStatus(scaleChangeSignPoMappingCommand.getDocumentStatus());
		Integer transactionId=f_getMaxTransactionId();
		String userRole=ReleaseLockedUser.caseStatus(workQueueService.getCompanyId(parserOutput.getFillingId()), scaleChangeSignPoMappingCommand.getUser());
		parserOutputAuditTrail.setUserRole(userRole);
		parserOutputAuditTrail.setCreatedBy(scaleChangeSignPoMappingCommand.getUser().getUserId().intValue());
		parserOutputAuditTrail.setCreatedDate(new Date());
		parserOutputAuditTrail.setPoIndexOrder(parserOutput.getPoIndexOrder()!=null?parserOutput.getPoIndexOrder():0);
		parserOutputAuditTrail.setArsLabel(parserOutput.getPoAsRepLabel()!=null?parserOutput.getPoAsRepLabel():"");
		parserOutputAuditTrail.setBreakup(parserOutput.getPoBreakup()!=null?parserOutput.getPoBreakup():"");
		parserOutputAuditTrail.setPoNote(parserOutput.getNote()!=null?parserOutput.getNote():"");
		parserOutputAuditTrail.setNiItem(parserOutput.getNiItem()!=null?parserOutput.getNiItem():0);
		parserOutputAuditTrail.setNilLabel(parserOutput.getNilLabel()!=null?parserOutput.getNilLabel():"");
		parserOutputAuditTrail.setPoVal1(parserOutput.getPoAsRepVal1()!=null?parserOutput.getPoAsRepVal1():"");
		parserOutputAuditTrail.setPoVal2(parserOutput.getPoAsRepVal2()!=null?parserOutput.getPoAsRepVal2():"");
		parserOutputAuditTrail.setPoVal3(parserOutput.getPoAsRepVal3()!=null?parserOutput.getPoAsRepVal3():"");
		parserOutputAuditTrail.setPoVal4(parserOutput.getPoAsRepVal4()!=null?parserOutput.getPoAsRepVal4():"");
		parserOutputAuditTrail.setPoVal5(parserOutput.getPoAsRepVal5()!=null?parserOutput.getPoAsRepVal5():"");
		parserOutputAuditTrail.setPoVal6(parserOutput.getPoAsRepVal6()!=null?parserOutput.getPoAsRepVal6():"");
		parserOutputAuditTrail.setPoVal7(parserOutput.getPoAsRepVal7()!=null?parserOutput.getPoAsRepVal7():"");
		parserOutputAuditTrail.setPoVal8(parserOutput.getPoAsRepVal8()!=null?parserOutput.getPoAsRepVal8():"");
		parserOutputAuditTrail.setIsExtraction("N");
		parserOutputAuditTrail.setPoaTransactionId(transactionId);
		parserOutputAuditTrail.setPoSubSection(parserOutput.getPoSubSection()!=null?parserOutput.getPoSubSection():"");
		parserOutputAuditTrail.setPoId(parserOutput.getPoId());
		parserOutputAuditTrail.setSection(parserOutput.getPoSection());
		parserOutputAuditTrail.setNiItemSuggestive(parserOutput.getNiItemSuggstive());
		parserOutputAuditTrail.setPoCrudStatus("O");
		LOGGER.info("** End- getOriginalPORecordToPOATRecord method");
		
	}catch (Exception e) {
	LOGGER.info("** Error in getOriginalPORecordToPOATRecord methode methode:",e);
	return null;
	}
	return parserOutputAuditTrail;
}

@SuppressWarnings("unchecked")
@Override
public ParserOutput getParserOutputByPoID(Integer poId){
	
	
	try{
		HashMap<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("poId", poId);
		
		HashMap<String, Object> templateIDParameterMap = new HashMap<String, Object>();
		HashMap<String, Object> normItemParameterMap = new HashMap<String, Object>();
		
		List<ParserOutput> parserOutputList = (ArrayList<ParserOutput>) (Object) genericDaoImpl
				.findByNamedQuery(NamedQueryName.getParserOutputByPoID,
						ParserOutput.class, parameters);
		
		if(!CollectionUtils.isEmpty(parserOutputList)){
			ParserOutput parserOutput=parserOutputList.get(0);
			
			templateIDParameterMap.put("filingId", parserOutput.getFillingId());
			Filings templateId = genericDaoImpl.findByColumn(
					NamedQueryName.getTemplateId, Filings.class, templateIDParameterMap);
			if(templateId!=null){
				normItemParameterMap.put("templateId", templateId.getTemplateId());
				normItemParameterMap.put("niItem", parserOutput.getNiItem());
				List<NormItemLabels> normItemLabelsList  =(ArrayList<NormItemLabels>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNrmItmLblByTmplteNiItem, NormItemLabels.class, normItemParameterMap);
				if(normItemLabelsList!=null && normItemLabelsList.size()>0){
					NormItemLabels normItemLabels =normItemLabelsList.get(0);
					parserOutput.setNiItemSection(normItemLabels.getNilSection());
				}else{
					parserOutput.setNiItemSection(parserOutput.getPoSection());
				}
			}
			
			
			
			
			return parserOutput;
		}
	}catch(Exception e){
		e.printStackTrace();
	}
	
	return null;
}



@Override
public List<ArsPoCommand> f_fetchArsPoMAppingBYFilingIdandSectionList(Integer filingId, List<String> sectionList) throws Exception
{
	LOGGER.info("**Start--f_fetchArsPoMAppingBYFilingIdandSectionList() function");
	return normalizationViewDAO.f_fetchArsPoMAppingBYFilingIdandSectionList(filingId,sectionList);
}

@Override
@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
public boolean f_updatePoCrudAccountByPOID(int poId){
	LOGGER.info("** Start-f_updatePoCrudAccountByPOID methode NormalizationServiceImpl class");

	Map<String, Object> parameterMap = new HashMap<String, Object>();
	parameterMap.put("poId",poId);
	parameterMap.put("poCrudAccount","U");
	try{
		
	genericDaoImpl.updateByNamedQuery(NamedQueryName.updateCrudAccountPoId, ParserOutput.class,parameterMap);
	return true;
	}catch(Exception e){
	LOGGER.error("Error:",e);
	}
	LOGGER.info("** End-updateNormalizedLabelColumn methode NormalizationServiceImpl class");
	return false;
}

@Override
public List<Object> getNormalizedDataForXsl(int WqId, int fillingId,String sectionName) {
	LOGGER.info("getNormalizedDataForXsl started");
	Map<String, Object> parameterMap = new HashMap<String, Object>();
	parameterMap.put("fillingId", fillingId);
	parameterMap.put("sectionName", sectionName);
	List<Object> parserOutput = genericDaoImpl
			.findByNativeNamedQuery(
					NamedNativeQueryName.getNormalizedDataByFilingIdandStatementTypeForXsl,
					ParserOutput.class, parameterMap);
	LOGGER.info("getNormalizedDataForXsl completed with result");
	return parserOutput;
}

	
@SuppressWarnings("unchecked")
private Map<Integer, ParserOutputCommand> getPoIdArsLabelMapByFilingIdAndRefPoIdIsNotNull(Integer filingId) 
{
	Map<String, Object> parameterMap = new HashMap<String, Object>();
	Map<Integer, ParserOutputCommand> PoIdArsLabelMap = null;
	parameterMap.put("filingId", filingId);
	List<Object> parserOutputObjectList = (ArrayList<Object>) (Object) (genericDaoImpl.findByNamedQuery(NamedQueryName.getPoIdArsLabelMapByFilingIdAndRefPoIdIsNotNull, ParserOutput.class, parameterMap));
	ParserOutputCommand parserOutputCommand = null;
	if(parserOutputObjectList!=null && !parserOutputObjectList.isEmpty())
	{
		PoIdArsLabelMap = new HashMap<>();
		for (Object obj : parserOutputObjectList) {
			Object[] objIn = (Object[]) obj;
			parserOutputCommand = new ParserOutputCommand();
			if(objIn[1]!=null && objIn[1].toString().trim().length()>0)
			{
				parserOutputCommand.setPoId(Integer.parseInt(objIn[0].toString()));
				parserOutputCommand.setPoAsRepLabel(objIn[1] == null ? "" : objIn[1].toString());
				parserOutputCommand.setPoAsRepVal1(objIn[2] == null ? "" : objIn[2].toString());
				parserOutputCommand.setPoAsRepVal2(objIn[3] == null ? "" : objIn[3].toString());
				parserOutputCommand.setPoAsRepVal3(objIn[4] == null ? "" : objIn[4].toString());
				parserOutputCommand.setPoAsRepVal4(objIn[5] == null ? "" : objIn[5].toString());
				parserOutputCommand.setPoAsRepVal5(objIn[6] == null ? "" : objIn[6].toString());
				parserOutputCommand.setPoAsRepVal6(objIn[7] == null ? "" : objIn[7].toString());
				parserOutputCommand.setPoAsRepVal7(objIn[8] == null ? "" : objIn[8].toString());
				parserOutputCommand.setPoAsRepVal8(objIn[9] == null ? "" : objIn[9].toString());
				parserOutputCommand.setPoAsRepVal9(objIn[10] == null ? "" : objIn[10].toString());
				parserOutputCommand.setPoAsRepVal10(objIn[11] == null ? "" : objIn[11].toString());
				parserOutputCommand.setPoAsRepVal11(objIn[12] == null ? "" : objIn[12].toString());
				parserOutputCommand.setPoAsRepVal12(objIn[13] == null ? "" : objIn[13].toString());
				parserOutputCommand.setPoAsRepVal13(objIn[14] == null ? "" : objIn[14].toString());
				parserOutputCommand.setPoAsRepVal14(objIn[15] == null ? "" : objIn[15].toString());
				parserOutputCommand.setPoAsRepVal15(objIn[16] == null ? "" : objIn[16].toString());
				parserOutputCommand.setPoAsRepVal16(objIn[17] == null ? "" : objIn[17].toString());
				parserOutputCommand.setPoAsRepVal17(objIn[18] == null ? "" : objIn[18].toString());
				parserOutputCommand.setPoAsRepVal18(objIn[19] == null ? "" : objIn[19].toString());
				parserOutputCommand.setPoAsRepVal19(objIn[20] == null ? "" : objIn[20].toString());
				parserOutputCommand.setPoAsRepVal20(objIn[21] == null ? "" : objIn[21].toString());
				parserOutputCommand.setUploadId(objIn[22] == null ? 0 : Integer.parseInt(objIn[22].toString()));
				
				PoIdArsLabelMap.put(Integer.parseInt(objIn[0].toString()), parserOutputCommand);
			}
		}
	}
	return PoIdArsLabelMap;
}

	private boolean isDoubleValue(String value)
	{
		if(value!=null && !value.isEmpty())
		{
		value = value.replace(",", "");
		try {
			Double.parseDouble(value.toString().trim());
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
		}
		else
		{
			return false;
		}
	}
	
	public Map<Integer, List<ParserOutputCommand>> getChildRecordsforReviewMapping(Integer filingId){
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filingId", filingId);
		Map<Integer, List<ParserOutputCommand>> childRecordMap = new HashMap<Integer, List<ParserOutputCommand>>();
		try{
			List<Object> childRecordList = genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getChildRecordsforReviewMapping,ParserOutput.class, parameterMap);
			if(!CollectionUtils.isEmpty(childRecordList)){
				ParserOutputCommand parserOutputCommand = null;
				Object[] objectArray = null;
				Integer refPoId = null;
				List<ParserOutputCommand> parserOutputCommandList = null;
				for(Object object : childRecordList){
					parserOutputCommand = new ParserOutputCommand();
					objectArray = (Object[]) object;
					refPoId =objectArray[0]!=null? new Integer(objectArray[0].toString()) :0;
					parserOutputCommand.setRefPoId(refPoId);
					parserOutputCommand.setPoId(objectArray[1]!=null? new Integer(objectArray[1].toString()) :0);
					parserOutputCommand.setNiItem(objectArray[2]!=null? new Integer(objectArray[2].toString()) :0);
					parserOutputCommand.setNiItemSuggstive(objectArray[3]!=null? objectArray[3].toString() :"");
					parserOutputCommand.setPoSection(objectArray[4]!=null? objectArray[4].toString() :"");
					if(childRecordMap.containsKey(refPoId)){
						childRecordMap.get(refPoId).add(parserOutputCommand);
					}else{
						parserOutputCommandList = new LinkedList<ParserOutputCommand>();
						parserOutputCommandList.add(parserOutputCommand);
						childRecordMap.put(refPoId, parserOutputCommandList);
					}
				}
				return childRecordMap;
			}
			
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return null;
	}

	@SuppressWarnings("unchecked")
	@Override
	public int f_findOutValuesColumnCount(int filingId, String section) throws DataAccessException {
		LOGGER.info("** Start-- f_findOutValuesColumnCount methode");
		int colCountValue=0;
		try{
			Map<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("filingId", filingId);
			parameters.put("poSection", section);
			List<ParserOutput> columnValuesList=(ArrayList<ParserOutput>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getValuesColumnCount, ParserOutput.class, parameters);
			if(!CollectionUtils.isEmpty(columnValuesList)){
				colCountValue=getColumnCount(columnValuesList);
			}
			
			LOGGER.info("** End-- f_findOutValuesColumnCount methode");
			return colCountValue;
		}catch(Exception e){
			e.printStackTrace();
			return colCountValue;
		}
		
	}


	@Override
	public List<String> isElementEnable(String screenName,Integer templateId) {
	        LOGGER.info("** Start--getTemplateList methode");
	    	Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("screenName", screenName);
			parameterMap.put("templateId", templateId);
			@SuppressWarnings("unchecked")
			List<String> templateAttrMappingObjList =(List<String>)(Object)genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.findScreenComponentMappingByTemplateName, UserGroupsAttributeMapping.class,parameterMap);
		   return templateAttrMappingObjList;
		}

	@Override
	public Integer getTotalRecords(Integer fillingId, String statementType, Integer parserId) 
	{
		LOGGER.info("*ClassName:NormalizationServiceImpl methode :getTotalRecords");
		  List<Object> countTotalRows =null;
		  Number num=null;
		  HashMap<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("fillingId", fillingId);
			parameters.put("statementType", statementType);
			if(statementType.equalsIgnoreCase("SUPPL")){
			    countTotalRows= genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.totalRows, ParserOutput.class,parameters);
			}else{
				countTotalRows= genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.totalRows_SUPPL, ParserOutput.class,parameters);	
			}
		    if (!countTotalRows.isEmpty()) {
				 num= (Number) countTotalRows.get(0);
			}	
	return num.intValue();
}
	/**
	 * This method used in export normalization functionality 
	 */
	@Override
	public List<Object> getNormalizedDataForExcel(int fillingId,Set<String> sectionSet) {
		LOGGER.info("getNormalizedDataForExcel started");
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("sectionSet", sectionSet);
		List<Object> parserOutput = null;
		try {
			parserOutput = normalizationViewDAO.getNormalizedDataForExcel(fillingId, sectionSet);
		} catch (Exception e) {
			e.printStackTrace();
		}
		LOGGER.info("getNormalizedDataForXsl completed with result");
		return parserOutput;
	}

	@SuppressWarnings("unused")
	@Override
	public Map<String, Map<String, List<? extends Object>>> f_createNormalizedViewExportData(Map<String, List<NormalisedLabelAndValues>> listOfNormalzedLabelsDetails,
			Map<String, List<String>> mapOfHeaders, List<String> listofHideClmns, String fileName,Map<String, List<NormalisedLabelAndValues>> ratioCalcultaionMap,Map<String,String> sectionDisplayHeaderMap,List<String> dataTableHeaders,String downloadType) {
		
		LOGGER.info("**start-f_createNormalizedViewExportData started");
		Map<String, Map<String, List<? extends Object>>>  dataValMap=new LinkedHashMap<>();
		/**
		 * Here we check Account Number,As Rep Label column exist in excel based on listofHideClmns
		 */
		int columnCounter=1;
		List<String> columnNameList=new ArrayList<>();
		columnNameList.add("Normalized Label");
		
		if(listofHideClmns!=null && !listofHideClmns.isEmpty()){
			if(listofHideClmns.contains("AccountNumber")){
			columnCounter++;
			columnNameList.add("AccountNumber");
			}
		}
/**
 * Here value1,value2,...value decied based on mapOfHeaders list size
 */
		int headerMapCountValue=0;
		for(String stmtDateAndPeriod:mapOfHeaders.keySet()){
			//Here Key is Statement Date and Period
			List<String> valueList=mapOfHeaders.get(stmtDateAndPeriod);
			if(headerMapCountValue<valueList.size()){
				headerMapCountValue=valueList.size();
			}
			
		}
		
	   columnCounter=columnCounter+headerMapCountValue;
		int ratioCalColCounter=columnCounter;
	   List<Object> objectList=new ArrayList<>();
	  
		//here we add first two row in objectList
	   for(String stmtDateAndPeriodListKey:mapOfHeaders.keySet()){
		   
		   
		   Object[] objIn = new Object[columnCounter];
			List<String> valueList=mapOfHeaders.get(stmtDateAndPeriodListKey);
			int colSeq=0;
			for(colSeq=0;colSeq<columnCounter;colSeq++){
				objIn[colSeq]=stmtDateAndPeriodListKey;
				colSeq=colSeq+1;
				break;
			}
			//here colSeq=1 and if accounumber is exist add blank value to it
			if(columnNameList.contains("AccountNumber")){
				objIn[colSeq]="";
				colSeq=colSeq+1;
			}
			int valuesListCounter=0;
			for(;colSeq<columnCounter;colSeq++){
				objIn[colSeq]=valueList.get(valuesListCounter);
				valuesListCounter=valuesListCounter+1;
			}
		   objectList.add(objIn);
	   }//end first two row data writting
	   
	   //Here we write Normalized Label,Account Number,As Rep Label row header in table and creare value1,value2...dynamically
	   for(String headerColVal:dataTableHeaders){
		   if(headerColVal.contains("Value")){
			   columnNameList.add(headerColVal);
		   }
	   }
	   if(!columnNameList.isEmpty() && columnNameList!=null){
	    List<ValueCommand> objectSubListMapSub=new LinkedList<>();
		ValueCommand valueCommand = null;
		if(!CollectionUtils.isEmpty(columnNameList))
		{
			StyleBuilder styleBuilder=new StyleBuilder();
			styleBuilder.setBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
			styleBuilder.setFillPattern(XSSFCellStyle.LEAST_DOTS);
			for (String headerName : columnNameList) 
			{
				valueCommand = new ValueCommand();
				valueCommand.setValue(headerName);
				if(headerName!=null && !headerName.isEmpty())
				{
					valueCommand.setStyleBuilder(styleBuilder);
				}
				objectSubListMapSub.add(valueCommand);
			}
		}	   
	  objectList.add(objectSubListMapSub);//add header row in excel
	  }//end columnList if
	  
	   
		for(String section:listOfNormalzedLabelsDetails.keySet()){
		List<NormalisedLabelAndValues> normalisedLabelAndValues=listOfNormalzedLabelsDetails.get(section);
		 List<ValueCommand> objectSubListMapSub=new LinkedList<>();
		 StyleBuilder styleBuilder=new StyleBuilder(); 
		 styleBuilder.setBoldWeight(XSSFFont.BOLDWEIGHT_BOLD);
			ValueCommand valueCommand = null;
			valueCommand = new ValueCommand();
			if(!CollectionUtils.isEmpty(sectionDisplayHeaderMap)){
				if(sectionDisplayHeaderMap.get(section)!=null){
					if(downloadType.equalsIgnoreCase("CSV"))
					valueCommand.setValue(sectionDisplayHeaderMap.get(section));
					else
					valueCommand.setValue(sectionDisplayHeaderMap.get(section)+":");
				}else{
					if(downloadType.equalsIgnoreCase("CSV"))
					valueCommand.setValue(section);
					else
					valueCommand.setValue(section+":");
				}
			}
			valueCommand.setStyleBuilder(styleBuilder);
			objectSubListMapSub.add(valueCommand);
			for (int colCount = 0; colCount>columnCounter;colCount++) 
			{
				valueCommand = new ValueCommand();
				valueCommand.setValue("");
				objectSubListMapSub.add(valueCommand);
			}
			objectList.add(objectSubListMapSub);
		 
		 /**Here write data in below section:**/
		
		 
		for(NormalisedLabelAndValues labelAndValues:normalisedLabelAndValues){
		Object[] onjInSubRow = new Object[columnCounter];
		int subRowCounter=0;
		
		if ("B".equals(labelAndValues.getDisplayFormat())){
		Map<String,StyleBuilder> objectSubListMap=new LinkedHashMap<>();
		onjInSubRow[subRowCounter]=labelAndValues.getLabel();
		StyleBuilder subStyleBuilder=new StyleBuilder();
		subStyleBuilder.setBoldWeight(XSSFFont.BOLDWEIGHT_BOLD);
		objectSubListMap.put(onjInSubRow[subRowCounter]==null ? "" :onjInSubRow[subRowCounter].toString() ,subStyleBuilder);
		subRowCounter=subRowCounter+1;
	
		if(columnNameList.contains("AccountNumber")){
    	 onjInSubRow[subRowCounter]=labelAndValues.getAccountId();
    	 objectSubListMap.put(onjInSubRow[subRowCounter]==null ? "" :onjInSubRow[subRowCounter].toString() ,null);
		 subRowCounter=subRowCounter+1;
		}
		 if(labelAndValues.getList()!=null && !labelAndValues.getList().isEmpty()){
			List<NormalizedDetails> valuesList=labelAndValues.getList();
			for(NormalizedDetails normalizedDetails:valuesList){
				if(normalizedDetails!=null)
				{
				onjInSubRow[subRowCounter]=normalizedDetails.getValue();
				objectSubListMap.put(onjInSubRow[subRowCounter]==null ? "" :onjInSubRow[subRowCounter].toString() ,null);
				}else{
				  objectSubListMap.put(onjInSubRow[subRowCounter]==null ? "" :onjInSubRow[subRowCounter].toString() ,null);
				}
			subRowCounter++;
				}
			}//end if values list list
			objectList.add(objectSubListMap);
		
		}//end B font style if
		else{
		 onjInSubRow[subRowCounter]=labelAndValues.getLabel();	
		subRowCounter=subRowCounter+1;
		if(columnNameList.contains("AccountNumber")){
		 onjInSubRow[subRowCounter]=labelAndValues.getAccountId();
		 subRowCounter=subRowCounter+1;
		}
	
		if(labelAndValues.getList()!=null && !labelAndValues.getList().isEmpty()){
			List<NormalizedDetails> valuesList=labelAndValues.getList();
			for(NormalizedDetails normalizedDetails:valuesList){
				if(normalizedDetails!=null)
				{
					onjInSubRow[subRowCounter]=normalizedDetails.getValue();
				}
				subRowCounter++;
			}
		}//end if values list list
		
		objectList.add(onjInSubRow);
		}

		if(listofHideClmns!=null && !listofHideClmns.isEmpty() && listofHideClmns.contains("AsRepLabel"))
		 {
			if(labelAndValues.getList()!=null && !labelAndValues.getList().isEmpty() && labelAndValues.getList().size()>0 ){
				//Here we add As Reported Lable Row with valuesList
				StyleBuilder styleBuilder2=new StyleBuilder();
				styleBuilder2.setItalic(true);
				styleBuilder2.setCellAllignment(CellStyle.ALIGN_RIGHT);
				styleBuilder2.setBoldWeight(XSSFFont.BOLDWEIGHT_NORMAL);
				styleBuilder2.setFontHeights((short) 8);
				styleBuilder2.setFontName("Tahoma");
			 List<NormalizedDetails> valuesList=labelAndValues.getList();
			 Set<Integer> keySet=new LinkedHashSet<>();
			 List<Map<Integer,ValueCommand>> mapList=new ArrayList<Map<Integer,ValueCommand>>();
			  for(NormalizedDetails normalizedDetails:valuesList){
				 if(normalizedDetails!=null){
				Map<Integer,ValueCommand> subValueMap=normalizedDetails.getLabelAndValueMap();
				if(normalizedDetails.getLabelAndValueMap()!=null){
				keySet.addAll(normalizedDetails.getLabelAndValueMap().keySet());
				}
				mapList.add(subValueMap);
				}
				 else
				 {
					 mapList.add(null);	 
				 }
			 }
			 //Itereare key set
			  if(!keySet.isEmpty() && keySet.size()>0 && keySet!=null){
			  Map<Integer,List<ValueCommand>> labelValFinalMap=new LinkedHashMap<>();
			  for(Integer poId:keySet){
				
				List<ValueCommand> valueList=new ArrayList<ValueCommand>();  
				for(Map<Integer,ValueCommand> mapObj:mapList){
				 if(mapObj!=null && mapObj.get(poId)!=null){
			     valueList.add((mapObj.get(poId)));
				 }
				 else
				 {
					 valueList.add(null);
				 }
				}
			labelValFinalMap.put(poId, valueList);
			  }
		//Now write data cell wise
				for (Map.Entry<Integer, List<ValueCommand>> entry : labelValFinalMap.entrySet())
				{
					objectSubListMapSub=new LinkedList<>();
					valueCommand = new ValueCommand();
					
				int findNotNullObjectCount = 0;
					if(entry.getValue()!=null && !entry.getValue().isEmpty())
					{
						for( ValueCommand listValue : entry.getValue())
						{
							if(listValue!=null)
							{
								break;
							}
							findNotNullObjectCount++;
						}
						valueCommand.setValue(entry.getValue().get(findNotNullObjectCount).getAsRepLabel());
					}
					valueCommand.setStyleBuilder(styleBuilder2);
					objectSubListMapSub.add(valueCommand);
					
					 if(columnNameList.contains("AccountNumber")){
						 valueCommand = new ValueCommand();
							valueCommand.setValue("");
							objectSubListMapSub.add(valueCommand);
					 }
					List<ValueCommand> valueList=entry.getValue();
					for(ValueCommand value:valueList){
						valueCommand = new ValueCommand();
						String valueString=null;
						if(value!=null)
						{
							valueString =value.getValue();
						}
						
						if(isDoubleValue(valueString))
						{
							double values = Double.parseDouble(valueString);
							valueString=decimalFormat.format(values);
						}
						valueCommand.setValue(valueString);
						valueCommand.setStyleBuilder(styleBuilder2);
						objectSubListMapSub.add(valueCommand);
					}
				objectList.add(objectSubListMapSub);	
				}
			  }//end key set empty condition
			}//sub row writting 	
			
		 }

	}//end 
 }
		Map<String, List<? extends Object>> tableValMap=new LinkedHashMap<>();
		tableValMap.put("Table1",objectList);
		dataValMap.put("Normalized View", tableValMap);
		if(ratioCalcultaionMap!=null && !ratioCalcultaionMap.isEmpty())
		dataValMap=f_getRatioCalculationData(dataValMap,columnNameList,ratioCalcultaionMap,ratioCalColCounter);
		LOGGER.info("**end-f_createNormalizedViewExportData started");
		
		return dataValMap;
	}
	
	
	public Map<String, Map<String, List<? extends Object>>> f_getRatioCalculationData(
			Map<String, Map<String, List<? extends Object>>> dataValMap,List<String> columnNameList,Map<String, List<NormalisedLabelAndValues>> ratioCalcultaionMap,Integer columnCounter)
	{
		   List<Object> objectList=new ArrayList<>();
		   //Here we write Normalized Label,Account Number,As Rep Label row header in table and create value1,value2...dynamically


	//Here we add table name
			Map<String, List<? extends Object>> tableValMap=new LinkedHashMap<>();
		   StyleBuilder styleBuilderTableHeader=new StyleBuilder();
		   styleBuilderTableHeader.setBackgroundColor(IndexedColors.GREY_50_PERCENT.getIndex());
		   styleBuilderTableHeader.setBoldWeight(XSSFFont.BOLDWEIGHT_BOLD);
		   
			StyleBuilder styleBuilder=new StyleBuilder();
			styleBuilder.setBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
			styleBuilder.setFillPattern(XSSFCellStyle.LEAST_DOTS);
			styleBuilderTableHeader.setBoldWeight(XSSFFont.BOLDWEIGHT_BOLD);

			
			//command header
			   if(!columnNameList.isEmpty() && columnNameList!=null)
			   { 
				   List<ValueCommand> objectSubListMapSub=new LinkedList<>();
			    objectSubListMapSub=new LinkedList<>();
			    ValueCommand valueCommand = null;
				 valueCommand = null;
				if(!CollectionUtils.isEmpty(columnNameList))
				{
					for (String headerName : columnNameList) 
					{
						valueCommand = new ValueCommand();
						if(headerName.equalsIgnoreCase("Normalized Label"))
						{
							headerName="Ratio Label";
						}
						valueCommand.setValue(headerName);
						if(headerName!=null && !headerName.isEmpty())
						{
							valueCommand.setStyleBuilder(styleBuilder);
						}
						objectSubListMapSub.add(valueCommand);
					}
				}	   
			  objectList.add(objectSubListMapSub);//add header row in excel
			  }//end columnList if
			//end column header.
			   
		   for(String tableHeaderName:ratioCalcultaionMap.keySet())
		   {
		   List<ValueCommand> objectSubListMapSub=new LinkedList<>();
		   ValueCommand valueCommand = null;
		   valueCommand = new ValueCommand();
		   valueCommand.setValue(tableHeaderName);
		   valueCommand.setStyleBuilder(styleBuilderTableHeader);
		   objectSubListMapSub.add(valueCommand);
		   objectList.add(objectSubListMapSub);
	//end table header row
		   
		
		  
		   
		   	//here we add first two row in objectList
				List<NormalisedLabelAndValues> normalisedLabelAndValues=ratioCalcultaionMap.get(tableHeaderName);
				for(NormalisedLabelAndValues labelAndValues:normalisedLabelAndValues)
				{
				Object[] onjInSubRow = new Object[columnCounter];
				int subRowCounter=0;
				
			    onjInSubRow[subRowCounter]=labelAndValues.getLabel();	
				subRowCounter=subRowCounter+1;
				if(columnNameList.contains("AccountNumber")){
				 onjInSubRow[subRowCounter]=labelAndValues.getAccountId();
				 subRowCounter=subRowCounter+1;
				}
			
				if(labelAndValues.getList()!=null && !labelAndValues.getList().isEmpty()){
					List<NormalizedDetails> valuesList=labelAndValues.getList();
					for(NormalizedDetails normalizedDetails:valuesList){
						if(normalizedDetails!=null)
						{
							onjInSubRow[subRowCounter]=normalizedDetails.getValue();
						}
						subRowCounter++;
					}
				}//end if values list list
				
				objectList.add(onjInSubRow);
			}//end child row insertion
				
		   }//end table header mapping data

		    tableValMap.put("Table1",objectList);
			dataValMap.put("Ratio Calculation", tableValMap);
			return dataValMap;
	}
	
	@Override
	public List<ParserOutput> getAsRepLabelContextTxtValues(Integer fillingId) {
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("filing_id", fillingId);
		List<ParserOutput> parserData=null;  
		ResourceBundle getQuery = ResourceBundle.getBundle("oracleSqlQuerys");
	     String  getAsRepLabelConextData=getQuery.getString("getAsRepLabelContextData");
		List<Object[]> parserOutputObj=genericDaoImpl.findBySql(getAsRepLabelConextData, parameterMap);
		if(parserOutputObj!=null && !parserOutputObj.isEmpty()){
			parserData=new ArrayList<ParserOutput>();
			ParserOutput parserObj=null;
			for(Object object:parserOutputObj){
				Object[] objIn = (Object[]) object;
				parserObj=new ParserOutput();
				parserObj.setPoId(objIn[1] == null ? 0 : Integer.parseInt(objIn[1].toString()));
				parserObj.setPoAsRepLabel(objIn[0] == null ? "" : objIn[0].toString());
				parserObj.setPoSection((objIn[2] == null ? "" : objIn[2].toString()));
				parserData.add(parserObj);
			}
		}
		return parserData;
		
		
		
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public boolean updateByAsRepLabelPoId(Integer fillingId,String asRepLableSection, Integer asRepLable_PoId, List<Integer> poids) {
		boolean updatedFlag=false;
		List<Object>  parserOutputIndexOrder =null;
		List<Integer> maxIndexOrder=null;
		int flag=0;
		int seqIndexOrder=0;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("asRefLabelPoid",asRepLable_PoId);
		parameterMap.put("asRepLableSection",asRepLableSection);
		
		parserOutputIndexOrder = genericDaoImpl.findByNamedQuery(NamedQueryName.getPoIndexOrderBySection,
				ParserOutput.class, parameterMap);
		for (Object object : parserOutputIndexOrder) {
			maxIndexOrder = new ArrayList<Integer>();
			maxIndexOrder.add(object != null ? Integer.parseInt(object.toString()) : 0);
		}	
		Integer indexOrderMax=maxIndexOrder.get(0);
		Integer finalIndexOrder=0;
		for(int i=0;i<poids.size();i++){
			seqIndexOrder=seqIndexOrder+10;
			finalIndexOrder=indexOrderMax+seqIndexOrder;
			parameterMap.put("poids",poids.get(i));
			parameterMap.put("insertMaxPoIndex",finalIndexOrder);
			flag=genericDaoImpl.updateByNamedQuery(NamedQueryName.updateRefPoIdByPoId, ParserOutput.class,parameterMap);		
		}
		if(flag > 0){
			updatedFlag=true;
		}	
		return updatedFlag;
	}

	@Override
	public List<ParserOutput> getNormalizedDataForQAChecks(String stmtFormat,int fillingId,String modifiedBy) throws Exception{
		LOGGER.info("getNormalizedDataForQAChecks started");
		List<ParserOutput> parserOutput = null;
		
		try {
			parserOutput = normalizationViewDAO.getParserOutputByFilingAndSectionForQACheck(fillingId, stmtFormat,modifiedBy);
		} catch (Exception e) {
			e.printStackTrace();
		}
		LOGGER.info("getNormalizedDataForQAChecks ends");
		return parserOutput;
	}
	
	
	private int getColumnCount(List<ParserOutput> columnValuesList) throws DataAccessException {
		LOGGER.info("** Start-- f_findOutValuesColumnCount methode");
		
		int colCountValue=0;
		List<Integer> columnList=new ArrayList<Integer>();
		for(ParserOutput parserOutput:columnValuesList){
			
		if(parserOutput.getPoAsRepVal20()!=null && !parserOutput.getPoAsRepVal20().isEmpty()){
		columnList.add(20);
		break;
		}if(parserOutput.getPoAsRepVal19()!=null && !parserOutput.getPoAsRepVal19().isEmpty()){
		columnList.add(19);
		}if(parserOutput.getPoAsRepVal18()!=null && !parserOutput.getPoAsRepVal18().isEmpty()){
			columnList.add(18);
		}if(parserOutput.getPoAsRepVal17()!=null && !parserOutput.getPoAsRepVal17().isEmpty()){
			columnList.add(17);
		}if(parserOutput.getPoAsRepVal16()!=null && !parserOutput.getPoAsRepVal16().isEmpty()){
			columnList.add(16);
		}if(parserOutput.getPoAsRepVal15()!=null && !parserOutput.getPoAsRepVal15().isEmpty()){
			columnList.add(15);
		}if(parserOutput.getPoAsRepVal14()!=null && !parserOutput.getPoAsRepVal14().isEmpty()){
			columnList.add(14);
		}if(parserOutput.getPoAsRepVal13()!=null && !parserOutput.getPoAsRepVal13().isEmpty()){
			columnList.add(13);
		}if(parserOutput.getPoAsRepVal12()!=null && !parserOutput.getPoAsRepVal12().isEmpty()){
			columnList.add(12);
		}if(parserOutput.getPoAsRepVal11()!=null && !parserOutput.getPoAsRepVal11().isEmpty()){
			columnList.add(11);
		}if(parserOutput.getPoAsRepVal10()!=null && !parserOutput.getPoAsRepVal10().isEmpty()){
			columnList.add(10);
		}if(parserOutput.getPoAsRepVal9()!=null && !parserOutput.getPoAsRepVal9().isEmpty()){
			columnList.add(9);
		}if(parserOutput.getPoAsRepVal8()!=null && !parserOutput.getPoAsRepVal8().isEmpty()){
			columnList.add(8);
		}if(parserOutput.getPoAsRepVal7()!=null && !parserOutput.getPoAsRepVal7().isEmpty()){
			columnList.add(7);
		}if(parserOutput.getPoAsRepVal6()!=null && !parserOutput.getPoAsRepVal6().isEmpty()){
			columnList.add(6);
		}if(parserOutput.getPoAsRepVal5()!=null && !parserOutput.getPoAsRepVal5().isEmpty()){
			columnList.add(5);
		}if(parserOutput.getPoAsRepVal4()!=null && !parserOutput.getPoAsRepVal4().isEmpty()){
			columnList.add(4);
		}if(parserOutput.getPoAsRepVal3()!=null && !parserOutput.getPoAsRepVal3().isEmpty()){
			columnList.add(3);
		}if(parserOutput.getPoAsRepVal2()!=null && !parserOutput.getPoAsRepVal2().isEmpty()){
			columnList.add(2);
		}if(parserOutput.getPoAsRepVal1()!=null && !parserOutput.getPoAsRepVal1().isEmpty()){
			columnList.add(1);
		}
		}//end for
		
		 if(columnList!=null && !columnList.isEmpty()){
    		colCountValue=Collections.max(columnList);
			}
		LOGGER.info("** End-- f_findOutValuesColumnCount methode");
		return colCountValue;
	}


	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutput> f_getQANormDataBycheckId(Integer checkId,Integer fillingId,String poSection,String isSubSection,Integer firstRecord,Integer displayRecords,Integer colCountValue){

		List<ParserOutput> parserOutputList = new ArrayList<ParserOutput>();;
		try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("checkId", checkId);
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("poSection", poSection);
		parameterMap.put("statementType", poSection);
		String subSection="";
		if(isSubSection.equalsIgnoreCase("Y")){
		List<String> subSectionList = (List<String>)(Object) genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getQANormDataBycheckId,QAMessageChecklist.class, parameterMap);
		 if(!CollectionUtils.isEmpty(subSectionList) && subSectionList!=null && !subSectionList.isEmpty() && subSectionList.size()>0){
		  subSection=subSectionList.get(0)!=null?subSectionList.get(0).trim() :"";
		 }
		}
		User userObject = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		List<String> isElementEnable=null;
		isElementEnable= workQueueService.isEnableFlag("Qa CheckList",userObject.getUserGroupId());
		String numberFormatCheckForMappedUnmappedItems="N";
		if (!CollectionUtils.isEmpty(isElementEnable)) {
			if (isElementEnable.contains("MapUnmapped Number format")) {
				numberFormatCheckForMappedUnmappedItems = "Y";
			}
		}
		 parserOutputList = normalizationViewDAO.f_getParserOutputByFilingIdandStatementTypeForNormQACheck(fillingId, poSection,subSection,isSubSection,firstRecord,displayRecords,colCountValue,numberFormatCheckForMappedUnmappedItems);
		
		}catch(Exception ex){
			ex.printStackTrace();
		}
		return parserOutputList;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<QACheckFilterMapping> getPoModifyByList(){
		try{
			List<QACheckFilterMapping> poModifyByList = (ArrayList<QACheckFilterMapping>) (Object) (genericDaoImpl
					.findByNamedQuery(NamedQueryName.getPoModifyByMetadataList, QACheckFilterMapping.class));
				return poModifyByList;
			
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		
	}
	
	
	@Override
	public Integer f_getQANormDataCountBycheckId(Integer fillingId,String poSection,Integer colCountValue){

		int count=0;
		try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("statementType", poSection);
		
		count = normalizationViewDAO.f_getCountParserOutputByFilingIdandStatementTypeForNormQACheck(fillingId, poSection,colCountValue);

		}catch(Exception ex){
			ex.printStackTrace();
		}
		return count;
	}
	
	
	@SuppressWarnings("unchecked")
	@Override
	public int f_findOutValuesColumnCountForQaCheckBreakup(int filingId, String section,String modifiedBy) throws DataAccessException {
		LOGGER.info("** Start-- f_findOutValuesColumnCountForQaCheckBreakup method");
		int colCountValue=0;
		try{
			Map<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("filingId", filingId);
			parameters.put("poSection", section);
			parameters.put("modifiedBy", modifiedBy);
			List<ParserOutput> columnValuesList=(ArrayList<ParserOutput>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getValuesColumnCountByModifiedBy, ParserOutput.class, parameters);
			if(!CollectionUtils.isEmpty(columnValuesList)){
				colCountValue=getColumnCount(columnValuesList);
			}
			
			LOGGER.info("** End-- f_findOutValuesColumnCountForQaCheckBreakup method");
			return colCountValue;
		}catch(Exception e){
			e.printStackTrace();
			return colCountValue;
		}
		
	}
	
	
	@Override
	public List<Object> getFinancialItemsByFilter(FinancialItemsCommand financialItemsCommand){
		try{
			
			return normalizationViewDAO.getFinancialItemsByFilter(financialItemsCommand);
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		
	}
	
	@SuppressWarnings("unchecked")
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public String bulkUpdateFinancialItems(List<FinancialItemsCommand> financialItemsCommandList,User userObject){
		try{
			//String results="";
			int companyLevelUpdateCount=normalizationViewDAO.bulkUpdateFinancialItems(financialItemsCommandList);
			Set<Integer> fiIdSet = new HashSet<Integer>();
			int index=1;
			int mapIndex =1;
			Map<Integer,Set<Integer>> fiIdMap = new HashMap<Integer, Set<Integer>>(); 
			for(FinancialItemsCommand financialItemsCommand :financialItemsCommandList){
				if(index%500==0){
					fiIdMap.put(mapIndex, fiIdSet);
					mapIndex++;
					fiIdSet = new HashSet<Integer>();
				}
				fiIdSet.add(financialItemsCommand.getFiId());
				if(index == financialItemsCommandList.size()){
					fiIdMap.put(mapIndex, fiIdSet);
				}
				index++;
			}
			int  globalUpdateCount=0;
			List<FinancialItems> globalFinancialItemsList=new ArrayList<FinancialItems>();
			if(!CollectionUtils.isEmpty(fiIdMap)){
				Map<String, Object> parameters = new HashMap<String, Object>();
				Map<String, Object> findFiListGlobalLevelparameterMap = new HashMap<String, Object>();
				List<FinancialItems> fiIdObjectList=null;
				List<FinancialItems> financialItemsList=null;
				FinancialItems globalFinancialItems=null;
				FinancialItemsCommand globalFinancialItemsCommand=null;
				List<FinancialItemsCommand> globalFinancialItemsCommandList=new ArrayList<FinancialItemsCommand>();
				for (Map.Entry<Integer, Set<Integer>> pair : fiIdMap.entrySet()) {
					parameters.put("fiIdList", pair.getValue());
					financialItemsList=(ArrayList<FinancialItems>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getFinancialItemsbyFiIdlist, FinancialItems.class, parameters);
					if(!CollectionUtils.isEmpty(financialItemsList)){
						for(FinancialItems financialItems:financialItemsList){
							findFiListGlobalLevelparameterMap = new HashMap<String, Object>();
							findFiListGlobalLevelparameterMap.put("templateId", financialItems.getTemplateId());
							findFiListGlobalLevelparameterMap.put("fiLabel", financialItems.getFiLabel()==null?financialItems.getFiLabel():financialItems.getFiLabel().trim());
							findFiListGlobalLevelparameterMap.put("fiSection", financialItems.getFiSection()==null?financialItems.getFiSection():financialItems.getFiSection().trim());
							findFiListGlobalLevelparameterMap.put("fiSubSection", financialItems.getFiSubSection()==null?financialItems.getFiSubSection():financialItems.getFiSubSection().trim());
							fiIdObjectList = (ArrayList<FinancialItems>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.findFinancialItemListForGlobalLevel, FinancialItems.class,findFiListGlobalLevelparameterMap);
							if(!CollectionUtils.isEmpty(fiIdObjectList)){
								for(FinancialItems selectedFinancialtems:fiIdObjectList){
									globalFinancialItemsCommand= new FinancialItemsCommand();
										if("Pending".equalsIgnoreCase(selectedFinancialtems.getFiStatus()))
										{
											globalFinancialItemsCommand.setFiId(selectedFinancialtems.getFiId());
											globalFinancialItemsCommandList.add(globalFinancialItemsCommand);
										}
								}
							}else {
								globalFinancialItems= new FinancialItems();
								globalFinancialItems.setFiLabel(financialItems.getFiLabel());
								globalFinancialItems.setFiSection(financialItems.getFiSection());
								globalFinancialItems.setFiSubSection(financialItems.getFiSubSection());
								globalFinancialItems.setNiItem(financialItems.getNiItem());
								globalFinancialItems.setFiIndexOrder(financialItems.getFiIndexOrder());
								globalFinancialItems.setTemplateId(financialItems.getTemplateId());
								globalFinancialItems.setFiIndustry(financialItems.getFiIndustry());
								globalFinancialItems.setFiLanguage(financialItems.getFiLanguage());
								globalFinancialItems.setCreatedDate(new Date());
								globalFinancialItems.setAnalystId((int) (long) userObject.getUserId());
								globalFinancialItems.setCreatedBy(userObject.getUsername());
								globalFinancialItems.setFiSearchType("GlobalLevel");
								globalFinancialItems.seteId(0);
								globalFinancialItems.setHeaderLabel(financialItems.getHeaderLabel());
								globalFinancialItems.setTableLabel(financialItems.getTableLabel());
								globalFinancialItems.setFiStatus("Approved");
								globalFinancialItems.setIndustryId(0);
								
								if(financialItems.getParserDescription()!=null && financialItems.getParserDescription().equalsIgnoreCase("PDF Based ITR"))
								{
									globalFinancialItems.setIsParserSpecific("Y");
									globalFinancialItems.setParserDescription("PDF Based ITR");
								}
								globalFinancialItemsList.add(globalFinancialItems);
							}
						}
					}
						
					}
					
					if(!CollectionUtils.isEmpty(globalFinancialItemsCommandList)){
						globalUpdateCount =normalizationViewDAO.bulkUpdateFinancialItems(globalFinancialItemsCommandList);
					}
					
					if(!CollectionUtils.isEmpty(globalFinancialItemsList)){
						genericDaoImpl.persist(globalFinancialItemsList);
						
						
						
						
					}
				}
			
			return companyLevelUpdateCount+"~"+globalUpdateCount+"~"+globalFinancialItemsList.size();
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		
	}
	
	
	@Override
	public ParserOutput f_getStatementYearParserOutputData(Integer fillingId,String poSection,Integer colCountValue)
	{
		return normalizationViewDAO.f_getParserOutputStatementYearByFilingIdandStatementTypeForNormQACheck(fillingId, poSection,colCountValue);
	}
	
	
	@Override
	public List<Object> getPdfExtractionMetaDataListByByFilter(PdfExtractionMetadatCommand pdfExtractionMetadatCommand){
		try{
			
			return normalizationViewDAO.getPdfExtractionMetaDataListByByFilter(pdfExtractionMetadatCommand);
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
	}
	
	
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.RAGE_TX_MANAGER)
	public String bulkUpdateExtractionRules(List<PdfExtractionMetadatCommand> pdfExtractionMetadatCommandList,User userObject){
		try{
			if(!CollectionUtils.isEmpty(pdfExtractionMetadatCommandList)){
				int pemUpdateCount=normalizationViewDAO.bulkUpdateExtractionRules(pdfExtractionMetadatCommandList);
				SectionIdentification sectionIdentification = null;
				List<SectionIdentification> sectionIdentificationList = new LinkedList<SectionIdentification>();
				List<Object> sectionIdentificationListNySectionKeyWord=null;
				HashMap<String, Object> parameters = new HashMap<String, Object>();
				for(PdfExtractionMetadatCommand pdfExtractionMetadatCommand :pdfExtractionMetadatCommandList){
					parameters = new HashMap<String, Object>();
					parameters.put("sectionName", pdfExtractionMetadatCommand.getSection().trim());
					parameters.put("keyWord", pdfExtractionMetadatCommand.getBeginKeyword().trim());
					sectionIdentificationListNySectionKeyWord=genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.SectionIdentificationBySectionKeyWord, SectionIdentification.class, parameters);
					if(CollectionUtils.isEmpty(sectionIdentificationListNySectionKeyWord)){
						sectionIdentification= new SectionIdentification();
						sectionIdentification.setLanguage(pdfExtractionMetadatCommand.getLanguage());
						sectionIdentification.setSectionName(pdfExtractionMetadatCommand.getSection());
						sectionIdentification.setKeyWord(pdfExtractionMetadatCommand.getBeginKeyword());
						sectionIdentification.setIsReviewed("Y");
						sectionIdentification.setCreatedBy(userObject.getLogin());
						sectionIdentification.setCreatedDate(new Date());
						sectionIdentification.setRowSegmentationType(pdfExtractionMetadatCommand.getRowSegmentationType());
						sectionIdentification.setColumnSplit((pdfExtractionMetadatCommand.getColumnNoToSplit()!=null && !"".equalsIgnoreCase(pdfExtractionMetadatCommand.getColumnNoToSplit().trim()))?new Integer(pdfExtractionMetadatCommand.getColumnNoToSplit()):0);
						sectionIdentificationList.add(sectionIdentification);
					}
				}
				genericDaoImpl.persist(sectionIdentificationList);
				
				
				return pemUpdateCount+"~"+sectionIdentificationList.size();
			}else{
				return "";
			}
			
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		
	}

	@SuppressWarnings("unchecked")
	@Override
	public String getDownloadControllerByTemplateId(Integer templateId) throws Exception 
	{
		String defaultController = "normalizedViewExportToExcel";
		String templateController=null;
				List<DownloadTemplateControllerAssociation> templateControllerAssociation = (List<DownloadTemplateControllerAssociation>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getDownloadTemplateController,DownloadTemplateControllerAssociation.class);
				if(!CollectionUtils.isEmpty(templateControllerAssociation))
				{
					for (DownloadTemplateControllerAssociation downloadTemplateControllerAssociation : templateControllerAssociation) 
					{
						if(downloadTemplateControllerAssociation.getTemplateId().intValue()==templateId.intValue())
						{
							templateController = downloadTemplateControllerAssociation.getControllerName();
							break;
						}
						else if(downloadTemplateControllerAssociation.getTemplateId().intValue() == -1)
						{
							defaultController = downloadTemplateControllerAssociation.getControllerName();
						}
					}
				}
				
				if(templateController==null)
				{
					templateController=defaultController;
				}
				return templateController;
		}
	
	
	private String getProcessedFilesFileTypeByFilingId(Integer filingId) 
	{
		String filePath = fileUploadService.f_getProcessedFilePathByFilingId(filingId);
		String fileType = FilenameUtils.getExtension(filePath);
		return fileType;
	}

	private String getProcessedFilesFileTypeByFilingIdAndUploadId(Integer filingId, Integer uploadId) 
	{
		String filePath = fileUploadService.f_getProcessedFilePath(filingId, uploadId);
		String fileType = FilenameUtils.getExtension(filePath);
		return fileType;
	}

	@Override
	public String checkBalancingValue(Integer nivId) throws Exception 
	{
		String balancingValue=null;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("niId", nivId);
		List<Object> balancingValueList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getBalancingValue, NIValues.class,parameterMap);
		if(balancingValueList!=null && !balancingValueList.isEmpty())
		{
			if(balancingValueList.get(0)!=null && balancingValueList.get(0).toString().length()>0)
			balancingValue = (String) balancingValueList.get(0).toString();
		}
		return balancingValue;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public String getSectionNameBySectionDisplayName(String sectionDisplayName) throws Exception 
	{

		String sectionName=null;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("sectionDisplayName", sectionDisplayName);
		List<String> sectionMappingList =(List<String>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getSectionNameByDisplayName, SectionMappingModel.class,parameterMap);
		if(!CollectionUtils.isEmpty(sectionMappingList))
		{
			sectionName= sectionMappingList.get(0).toString();
		}
		return sectionName;
	}
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
		public Filings getFilingsByFillingId(int filingId) {
			LOGGER.info("** start---getFilingsByFillingId method");
			Map<String, Object> parameterMap = new HashMap<String, Object>();
			parameterMap.put("filingId", filingId);
			Filings filings = genericDaoImpl.findByColumn(
					NamedQueryName.getTemplateId, Filings.class, parameterMap);

			if (null!=filings && filings.getTemplateId() != null) {
				LOGGER.info("** template id=" + filings.getTemplateId());
				return filings;
			}
			return null;
		}
	
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public List<NormalizationBreakupData> getchildNormalizedDataByNiIdForClickBack(NIValues niValues,Integer niItem) 
	{
		String refPoId = null;
		List<NormalizationBreakupData> normalizationBreakupDataList = null;
		NormalizationBreakupData normalizationBreakupData = null;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		
		parameterMap.put("niId", niValues.getNiId());
		List<Object> niIdList =genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getRefPoIds, NIValues.class,parameterMap);
		if(niIdList!=null && !niIdList.isEmpty())
		{
			refPoId = (String) niIdList.get(0);
		}
		String[] refPoIdDataArray = null;
		if(refPoId!=null && !refPoId.isEmpty())
		{
			refPoIdDataArray = refPoId.split(",");	
		}
		
		if(refPoIdDataArray!=null && refPoIdDataArray.length>0)
		{
			normalizationBreakupDataList = new ArrayList<NormalizationBreakupData>();
			for (String selectedDataString : refPoIdDataArray) 
			{
				String[] poIdArdDetailsDataAray = selectedDataString.split("-");
				if(poIdArdDetailsDataAray!=null && poIdArdDetailsDataAray.length==2)
				{
					Integer selectedPoId = Integer.parseInt(poIdArdDetailsDataAray[0].toString());
					String columnName = poIdArdDetailsDataAray[1].toString();
					String coordinateColumn = columnName.replace("PO", "CORD_DETAILS");
					columnName = "po."+columnName;
					coordinateColumn = "POCH."+coordinateColumn;
					normalizationBreakupData = normalizationViewDAO.normalizationBreakupDetails(selectedPoId,columnName,coordinateColumn);
					if(normalizationBreakupData!=null)
					{
						if(normalizationBreakupData.getIsCoordinateExists().equalsIgnoreCase("Y"))
						{
							String column =columnName.replace("po.PO_VAL", "val");
							normalizationBreakupData.setColumn(column);;
						}
						normalizationBreakupDataList.add(normalizationBreakupData);
					}
				}
			}
		}
		List<NormalizationBreakupData> finalNormalizationBreakupDataList = new ArrayList<NormalizationBreakupData>();
		List<NormalizationBreakupData> tempNormalizationBreakupDataList = new ArrayList<NormalizationBreakupData>();
		if(!CollectionUtils.isEmpty(normalizationBreakupDataList)){
			for (NormalizationBreakupData normalizationBreakupDataNew : normalizationBreakupDataList){
				if(niItem.equals(normalizationBreakupDataNew.getNiItem())){
					normalizationBreakupDataNew.setIsParent("Y");
					finalNormalizationBreakupDataList.add(normalizationBreakupDataNew);
				}else{
					normalizationBreakupDataNew.setIsParent("N");
					tempNormalizationBreakupDataList.add(normalizationBreakupDataNew);
				}
			}
		}
		finalNormalizationBreakupDataList.addAll(tempNormalizationBreakupDataList);
		return finalNormalizationBreakupDataList;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<ParserOutput> f_getQANormDataBycheckIdForSubTotal(Integer checkId,Integer fillingId,String poSection,String isSubSection,Integer firstRecord,Integer displayRecords,Integer colCountValue){

		List<ParserOutput> parserOutputList = new ArrayList<ParserOutput>();;
		try{
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("checkId", checkId);
		parameterMap.put("fillingId", fillingId);
		parameterMap.put("poSection", poSection);
		parameterMap.put("statementType", poSection);
		String subSection="";
		if(isSubSection.equalsIgnoreCase("Y")){
		List<String> subSectionList = (List<String>)(Object) genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getQANormDataBycheckId,QAMessageChecklist.class, parameterMap);
		 if(!CollectionUtils.isEmpty(subSectionList) && subSectionList!=null && !subSectionList.isEmpty() && subSectionList.size()>0){
		  subSection=subSectionList.get(0)!=null?subSectionList.get(0).trim() :"";
		 }
		}
		String numberFormatCheckForMappedUnmappedItems="Y";	
		parserOutputList = normalizationViewDAO.f_getParserOutputByFilingIdandStatementTypeForNormQACheck(fillingId, poSection,subSection,isSubSection,firstRecord,displayRecords,colCountValue,numberFormatCheckForMappedUnmappedItems);
		}catch(Exception e){
			LOGGER.error("Error..."+e);
			e.printStackTrace();
		}
		return parserOutputList;
	}
	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#getNormItemLabelDetailsByTemplateIdAndNiItem(java.lang.Integer, java.lang.Integer)
	 */
	@SuppressWarnings("unchecked")
	@Override
	public NormItemLabels getNormItemLabelDetailsByTemplateIdAndNiItem(Integer templateId, Integer niItemId)throws Exception 
	{
		NormItemLabels normItemLabels = null;
    	Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("templateId", templateId);
		parameterMap.put("niItem", niItemId);
		List<NormItemLabels> normItemLabelsList  =(ArrayList<NormItemLabels>) (Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNrmItmLblByTmplteNiItem, NormItemLabels.class, parameterMap);
		if(normItemLabelsList!=null && normItemLabelsList.size()>0){
			normItemLabels =normItemLabelsList.get(0);
		}
		return normItemLabels;
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.RAGE_TX_MANAGER)
	public Integer rageProcessRequestQueue(String processName,String parameters)
	{
		Integer requestId=0;
		LOGGER.info("--- **start--Request f_saveToRequestQueueForBatchProcessing--------");
		try {
			RequestQueue requestQueue = new RequestQueue();
			Map<String, Integer> processList = ProcessListGenerator.getProcessMap();
			Integer rageApplicationId = ProcessListGenerator.rageApplicationId;
			String jBossCategory = ProcessListGenerator.jbossCategory;
			Integer pkId = extractionService.generatePkForRequestQueue();
			requestQueue.setCmptSeqId(processList.get(processName));
			requestQueue.setApplSeqId(rageApplicationId);
			requestQueue.setApplName(rageApplicationName);
			requestQueue.setApplVersion("00.0");
			requestQueue.setRqCmptVersion("00.0*");
			requestQueue.setRqParameters(parameters);
			requestQueue.setRqScheduleDate(new Date());
			requestQueue.setRqSubmissionDate(new Date());
			if(rageMultithreading.equalsIgnoreCase("Y"))
			{
				requestQueue.setRqStatus(pkId+"");
				requestQueue.setJbossCategory(processName);
			}
			else
			{
				requestQueue.setRqStatus("Start");
				requestQueue.setJbossCategory(jBossCategory);
			}
			requestQueue.setUserSeqId(0);
			requestQueue.setRqPriority(0);
			requestQueue.setRqPeriodicschdlFlag("N");
			requestQueue.setRqUnits(0);
			requestQueue.setRqReferredruleid(0);
			requestQueue.setRequestId(pkId);
			rageDao.saveRequestQueue(requestQueue);
			requestId=requestQueue.getRequestId();
		} catch (Exception e) {
			e.printStackTrace();
			LOGGER.error(e.getStackTrace());
		}
		LOGGER.info("**End--Request f_saveToRequestQueueForBatchProcessing--------");
		return requestId;
	}

	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void saveInvokeProcessTracker(Integer requestId, Integer filingId, String processedFlag, String processName,Long userId) 
	{
		try {
			InvokeProcessTracker invokeProcessTracker = new InvokeProcessTracker();
			invokeProcessTracker.setRequestId(requestId);
			invokeProcessTracker.setFilingId(filingId);
			invokeProcessTracker.setProcessedFlag(processedFlag);
			invokeProcessTracker.setProcessName(processName);
			invokeProcessTracker.setUserId(userId);
			genericDaoImpl.persist(invokeProcessTracker);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#updateWqStatusByFilingId(java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void updateWqStatusByFilingId(Integer filingId,String workQueueStatus) throws Exception 
	{
		try{
			Map<String, Object> parameter = new HashMap<String, Object>();
			parameter.put("filingId", filingId);
			parameter.put("wqStatus", workQueueStatus);
			genericDaoImpl.updateByNamedQuery(NamedQueryName.updateWqStatusByFilingId,WorkQueue.class, parameter);
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#getNormItemLabelsByNiItemandTemplateId(java.lang.Integer, java.lang.Integer)
	 */
	@SuppressWarnings("unchecked")
	@Override
	public String getNormItemLabelsByNiItemAndTemplateId(Integer niItem, Integer templateId) throws Exception 
	{
		String NormItemLabel=null;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("niItem", niItem);
		parameterMap.put("templateId", templateId);
		List<String> normItemLabelList =(List<String>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getNormItemLabelsByNiItemAndTemplateId, NormItemLabels.class,parameterMap);
		if(!CollectionUtils.isEmpty(normItemLabelList))
		{
			NormItemLabel= normItemLabelList.get(0).toString();
		}
		return NormItemLabel;
	}

	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#getTemplateNameByTemplateId(java.lang.Integer)
	 */
	@SuppressWarnings("unchecked")
	@Override
	public String getTemplateNameByTemplateId(Integer templateId) throws Exception 
	{
		String templateName=null;
		Map<String, Object> parameterMap = new HashMap<String, Object>();
		parameterMap.put("templateId", templateId);
		List<String> templateIdList =(List<String>)(Object)genericDaoImpl.findByNamedQuery(NamedQueryName.getTemplateNameByTemplateId, NormItemLabels.class,parameterMap);
		if(!CollectionUtils.isEmpty(templateIdList))
		{
			templateName= templateIdList.get(0).toString();
		}
		return templateName;
	}
	
	/* (non-Javadoc)
	 * @see com.livespread.service.NormalizationService#updateWqStatusAndTemplateNameByFilingId(java.lang.Integer, java.lang.String, java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public void updateWqStatusAndTemplateNameByFilingId(Integer filingId, String workQueueStatus, String templateName)throws Exception 
	{
		try{
			Map<String, Object> parameter = new HashMap<String, Object>();
			parameter.put("filingId", filingId);
			parameter.put("wqStatus", workQueueStatus);
			parameter.put("industryName", templateName);
			genericDaoImpl.updateByNamedQuery(NamedQueryName.updateWqStatusAndIndustryNameByFilingId,WorkQueue.class, parameter);
		}catch(Exception e){
			e.printStackTrace();
		}
	}

@Override
	@Transactional(propagation = Propagation.REQUIRED, value=ReusableConstant.APPLICATION_TX_MANAGER)
	public Map<String,Object> f_getFormulaCalPopUpValues(Integer templateId, Integer niItem,Integer arsIdNumber,Integer filingIdNumber) throws Exception {
		LOGGER.info("**start--f_getFormulaCalPopUpValues methode");
		Map<String, Object> parameter = new HashMap<String, Object>();
		parameter.put("templateId", templateId);
		parameter.put("niItem", niItem);
		parameter.put("category", "Derived");
		parameter.put("filingId", filingIdNumber);
		parameter.put("arsId", arsIdNumber);

		Map<String,Object> dataValMap=new LinkedHashMap<>();
		List<Object> normQaChecksMetaList  =(List<Object>)(Object) genericDaoImpl.findByNamedQuery(NamedQueryName.getFormulaBasedOnTemplateIdAndNiItem, NormQaChecksMeta.class, parameter);
		for(Object normQaChecksMetaObj:normQaChecksMetaList)
		{
			Object[] normQaChecksMetaObjIn = (Object[]) normQaChecksMetaObj;
		if(normQaChecksMetaObjIn!=null)
		{
			//&330&*(12/#stm.month#)/&590&
			String formula=normQaChecksMetaObjIn[0]!=null?normQaChecksMetaObjIn[0].toString():"";
			//String formula="&330&*(12/#stm.month#)/&590&";
		//	formula = formula.replaceAll("[()]", "");
			String[] formulaArray=formula.split("&");
			String finalFormula="";
			String regex = "[0-9]+"; 
			for(int i=0;i<formulaArray.length;i++)
			{
				if(formulaArray[i].trim()!="")
				{
					if(formulaArray[i].matches(regex)){
						Integer childNiItem=null;
						try{
						childNiItem=Integer.parseInt(formulaArray[i]);
						}catch(Exception e){
							e.printStackTrace();
						}
						
					 String normLabel = getNormItemLabelsByNiItemAndTemplateId(childNiItem,templateId);
					 finalFormula+=" "+normLabel;
					}else if(formulaArray[i].contains("#"))
					{
						//2/#stm.month#
						String[] formulaSubArray=formulaArray[i].split("#");
						for(int j=0;j<formulaSubArray.length;j++)
						{
								if (Character.isLetter(formulaSubArray[j].charAt(0))){
									 parameter.put("nilLabel", formulaSubArray[j]);
									 List<Object> normItemLabelList =(List<Object>)(Object) genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getNiValuesNiLableDataByNiLable, NormItemLabels.class,parameter);
									  for(Object object:normItemLabelList){
											if(object!=null)
											{
											Integer niVal=null;
											try{
												double niValDouble = Double.parseDouble(object.toString()!=null?object.toString():"");
												niVal = (int) niValDouble;	
											}catch(NumberFormatException nfe){
												LOGGER.error("Error in NI VALUE:"+nfe.getMessage());
											}
											finalFormula+=" "+niVal;
											}
										}
								}else{
									finalFormula+=" "+formulaSubArray[j];		
								}
						}
					}else{
					finalFormula+=" "+formulaArray[i];
					}
				}
			}
			
			dataValMap.put("formula",finalFormula);

			
		 String niItemList=normQaChecksMetaObjIn[1]!=null?normQaChecksMetaObjIn[1].toString():"";
		 
		 if(niItemList!=null & !niItemList.isEmpty())
		 {
			 String[] childNiItemArray=niItemList.split(",");
			if(childNiItemArray!=null && childNiItemArray.length>0)
			{
				Map<String,String> childLableValuesMap=new LinkedHashMap<>();
				for (int i = 0; i< childNiItemArray.length; i++)
				{
					try{
					 Integer childNiItem=Integer.parseInt(childNiItemArray[i]);
					 parameter.put("niItem", childNiItem);
					 List<Object> normItemLabelList =(List<Object>)(Object) genericDaoImpl.findByNativeNamedQuery(NamedNativeQueryName.getNiValuesNiLableDataByNiItem, NormItemLabels.class,parameter);

					for(Object object:normItemLabelList){
						Object[] objIn = (Object[]) object;
						childLableValuesMap.put(objIn[0]!=null?objIn[0].toString():"",objIn[1]!=null?objIn[1].toString():"");
					}
					}catch(NumberFormatException nfe){
						nfe.printStackTrace();
					}
				}//end for


				dataValMap.put("childTableData", childLableValuesMap);
				
			}
		 }
		}
		}//end for QACheckMEtafor loop
		LOGGER.info("**end--f_getFormulaCalPopUpValues methode");
		return dataValMap;
	}
	
	
	@Override
	public int f_getNiValuesClientDataCount(Integer filingId) {
		   LOGGER.info("** Start--f_getClientDataCount methode");
		   long rowCount=0;
	try{
		   Map<String, Object> parameters = new HashMap<String, Object>();
			parameters.put("filingId",filingId);
			rowCount=(long) genericDaoImpl.findByNamedQuery(NamedQueryName.countClientData, NIValues.class,parameters).get(0);
  	      LOGGER.info("** End--f_getUserGroupsCountByFlag methode");
		
	}catch(Exception e){
		e.printStackTrace();
	}
		return (int) rowCount;
	}

	@Override
	public List<ParserOutput> getNormalizedDataByRefPoId(NormInputParamers inputParams) 
	{
		List<ParserOutput> parserOutput = null;
		try {
			parserOutput = normalizationViewDAO.getParserOutputByFilingIdAndSectionAndRefPoId(inputParams);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return parserOutput;
	
	}
}
